{"./":{"url":"./","title":"序言","keywords":"","body":"序言参考联系公众号序言 这是一本关于集合 go 的书。 参考 Go 圣经 Go W3Cschool 联系 Email: 1zoxun1@gmail.com WeChat: weke59 Youtube: BlackSwanGreen Ins: cnghostwritten Bilibili: LoveDeatRobots 公众号 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:30:04 "},"Overview.html":{"url":"Overview.html","title":"目录","keywords":"","body":"SummarySummary 序言 summary Go Practice go 如何获取文件的大小 go 获取 url 实战 go 查找重复的行 go 编写 echo 命令 Go Base go goroot 与 gopath 介绍 go 通过 import 导入包 go 代理加速配置 go modules 管理包工具 go 基本类型 go const 定义常量 go 定义常量之 iota go type 声明变量 go 定义变量 go 运算符总结 go 指针概念 1 go 指针应用实践 go 流程控制 go array 数组 go slice 切片引用类型 go map容器引用 go struc 结构体 go 了解函数运用 go init 函数 go 内置函数 go 了解方法运用 go 了解接口运用 go panic 与 recover 异常处理 go defer 延迟调用 go 了解 goroutine 运用 go 了解 channel 管道 go container 容器数据类型 heap list ring go cas操作 Go Package go 库 pflag 命令行参数解析 go 库 viper 配置解析神器 go 包 fmt 打印输出 go 包 os 文件操作 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:32:51 "},"Go-Practice/":{"url":"Go-Practice/","title":"Go Practice","keywords":"","body":"Go PracticeGo Practice Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:21:35 "},"Go-Practice/go_get_file_size.html":{"url":"Go-Practice/go_get_file_size.html","title":"go 如何获取文件的大小","keywords":"","body":"Go 如何获取文件的大小1. Read字节方式2. ioutil方式3. Stat方法4. 终极方案5. 获取文件信息6. 判断文件是否存在7. 小结Go 如何获取文件的大小 1. Read字节方式 第一种，是最直观会想到的，也就是打开文件，把文件读取一遍。 func main() { file,err:=os.Open(\"water\") if err ==nil { sum := 0 buf:=make([]byte,2014) for { n,err:=file.Read(buf) sum+=n if err==io.EOF { break } } fmt.Println(\"file size is \",sum) } } 这种方式需要打开文件，通过for循环读取文件的字节内容，然后算出文件的大小，这样时也是最不能用的办法，因为效率低，代码量大。 2. ioutil方式 上面的代码比较啰嗦，这时候我们可能想到了使用ioutil包的ReadFile来代替，直接获得文件的内容，进而计算出文件的大小。 func main() { content,err:=ioutil.ReadFile(\"water\") if err == nil { fmt.Println(\"file size is \",len(content)) } } 通过ioutil.ReadFile函数，我们三行代码就可以搞定，的确方便很多，但是效率慢的问题依然，存在，如果是个很大的文件呢？ 3. Stat方法 继续再进一步，我们不读取文件的内容来计算了，我们通过文件的信息 func main() { file,err:=os.Open(\"water\") if err == nil { fi,_:=file.Stat() fmt.Println(\"file size is \",fi.Size()) } } 这种方式不会再读取文件的内容，而是通过Stat方法直接获取，速度会非常快，尤其对于大文件尤其有用。但是它还不是我们今天要讲的终极办法，因为它还是会打开文件，会占用它。 4. 终极方案 好了，我们的终极方案终于要登场了，他的代码也非常简单。 func main() { fi,err:=os.Stat(\"water\") if err ==nil { fmt.Println(\"file size is \",fi.Size(),err) } } 是的，也只需要三行代码即可实现，这里使用的是os.Stat，通过他可以获得文件的元数据信息，现在我们看看它能获取到哪些信息。 5. 获取文件信息 通过os.Stat方法，我们可以获取文件的信息，比如文件大小、名字等。 func main() { fi,err:=os.Stat(\"water\") if err ==nil { fmt.Println(\"name:\",fi.Name()) fmt.Println(\"size:\",fi.Size()) fmt.Println(\"is dir:\",fi.IsDir()) fmt.Println(\"mode::\",fi.Mode()) fmt.Println(\"modTime:\",fi.ModTime()) } } 运行这段代码看下结果: name: water size: 403 is dir: false mode:: -rw-r--r-- modTime: 2018-05-06 18:52:07 +0800 CST 以上就是可以获取到的文件信息，还包括判断是否是目录，权限模式和修改时间。所以我们对于文件的信息获取要使用os.Stat函数，它可以在不打开文件的情况下，高效获取文件信息。 6. 判断文件是否存在 os.Stat函数有两个返回值，一个是文件信息，一个是err，通过err我们可以判断文件是否存在。 首先，err==nil的时候，文件肯定是存在的；其次err!=nil的时候也不代表不存在，这时候我们就需要进行严密的判断。 func main() { _,err:=os.Stat(\".\") if err ==nil { fmt.Println(\"file exist\") }else if os.IsNotExist(err){ fmt.Println(\"file not exist\") }else{ fmt.Println(err) } } 通过os.IsNotExist来判断一个文件不存在。最后else的可能性比较少，这个时候可以看下具体的错误是什么，再根据错误来判断文件是否存在。 7. 小结 os.Stat是一个非常好的函数，可以让我们非常高效的获取文件信息，所以在项目中尽可能的使用它。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:23:35 "},"Go-Practice/go_get_URL.html":{"url":"Go-Practice/go_get_URL.html","title":"go 获取 url 实战","keywords":"","body":"Go 获取 URL 实战1. 获取一个 URL 的 body2. 并发获取多个 URLGo 获取 URL 实战 1. 获取一个 URL 的 body package main import ( \"fmt\" \"io/ioutil\" \"net/http\" \"os\" ) func main() { for _, url := range os.Args[1:] { resp, err := http.Get(url) //http.Get函数是创建HTTP请求的函数 if err != nil { fmt.Fprintf(os.Stderr, \"fetch: %v\\n\", err) os.Exit(1) } b, err := ioutil.ReadAll(resp.Body) //resp的Body字段包括一个可读的服务器响应流 resp.Body.Close() //resp.Body.Close关闭resp的Body流，防止资源泄露 if err != nil { fmt.Fprintf(os.Stderr, \"fetch: reading %s: %v\\n\", url, err) os.Exit(1) } fmt.Printf(\"%s\", b) } } $ go build url1.go $ ./url1 https://blog.csdn.net/ ....... 2. 并发获取多个 URL package main import ( \"fmt\" \"io\" \"io/ioutil\" \"net/http\" \"os\" \"time\" ) func main() { start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] { go fetch(url, ch) // start a goroutine } for range os.Args[1:] { fmt.Println( $ go build gopl.io/ch1/fetchall $ ./fetchall https://golang.org http://gopl.io https://godoc.org 0.14s 6852 https://godoc.org 0.16s 7261 https://golang.org 0.48s 2475 http://gopl.io 0.48s elapsed goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。 main函数中用make函数创建了一个传递string类型参数的channel，对每一个命令行参数，我们都用go这个关键字来创建一个goroutine，并且让函数在这个goroutine异步执行http.Get方法。这个程序里的io.Copy会把响应的Body内容拷贝到ioutil.Discard输出流中（译注：可以把这个变量看作一个垃圾桶，可以向里面写一些不需要的数据），因为我们需要这个方法返回的字节数，但是又不想要其内容。每当请求返回内容时，fetch函数都会往ch这个channel里写入一个字符串，由main函数里的第二个for循环来处理并打印channel里的这个字符串。 当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine往这个channel里写入、或者接收值，这样两个goroutine才会继续执行channel操作之后的逻辑。在这个例子中，每一个fetch函数在执行时都会往channel里发送一个值(ch Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:26:24 "},"Go-Practice/go_get_Duplicate_lines.html":{"url":"Go-Practice/go_get_Duplicate_lines.html","title":"go 查找重复的行","keywords":"","body":"Go 查找重复的行Go 查找重复的行 第一种：os.stdin package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { counts[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } 第二种：判断文件重复行 $ cat test.txt 1112 111 222 333 222 222 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 { countLines(os.Stdin, counts) } else { for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Fprintf(os.Stderr, \"dup2: %v\\n\", err) continue } countLines(f, counts) f.Close() } } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) //打印重复数与行内容 } } } func countLines(f *os.File, counts map[string]int) { input := bufio.NewScanner(f) for input.Scan() { counts[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() } $ go build dup2.go $ ./dup2 test.txt 3 222 第三种：根据标识符判断重复内容 $ cat test.txt 111 111 111 111 222 2 2 3 4 4 package main import ( \"fmt\" \"io/ioutil\" \"os\" \"strings\" ) func main() { counts := make(map[string]int) for _, filename := range os.Args[1:] { data, err := ioutil.ReadFile(filename) if err != nil { fmt.Fprintf(os.Stderr, \"dup3: %v\\n\", err) continue } for _, line := range strings.Split(string(data), \"\\n\") { counts[line]++ } } for line, n := range counts { if n > 1 { fmt.Printf(\"%d\\t%s\\n\", n, line) } } } $ ./dup3 a.txt 2 111 参考 书籍：go圣经 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:29:11 "},"Go-Practice/go_dev_command_echo.html":{"url":"Go-Practice/go_dev_command_echo.html","title":"go 编写 echo 命令","keywords":"","body":"Go 编写 echo 命令Go 编写 echo 命令 第一种 package main import ( \"fmt\" \"os\" ) func main() { var s, sep string for i := 1; i $ go build echo1.go $./echo1 $ ./echo1 1 1 $ ./echo1 13 4 13 4 $ /echo1 \"hello world\" hello world 第二种 利用 package main import ( \"fmt\" \"os\" ) func main() { s, sep := \"\", \"\" for _, arg := range os.Args[1:] { s += sep + arg sep = \" \" } fmt.Println(s) } $ go build echo2.go $ ./echo2 3 3 $ ./echo2 3 4 3 4 $ ./echo2 3 4 hello 3 4 hello 第三种 package main import ( \"fmt\" \"strings\" \"os\" ) func main() { fmt.Println(strings.Join(os.Args[1:], \" \")) } $ ./echo3 1 1 $ ./echo3 1 2 1 2 $ ./echo3 1 2 hello 1 2 hello 参考 书籍： go圣经 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 18:31:42 "},"Go-Base/":{"url":"Go-Base/","title":"Go Base","keywords":"","body":"Go 快速入门1. go 背景2. go 特点3. go 安装3.1 windows go3.2 UNIX/Linux/Mac OS X, 和 FreeBSD 安装4. go 学习网站5. go 开始Go 快速入门 1. go 背景 Go语言由来自Google公司的Robert Griesemer，Rob Pike和Ken Thompson三位大牛于2007年9月开始设计和实现，然后于2009年的11月对外正式发布。 2. go 特点 并发与协程 基于消息传递的通信方式 丰富实用的内置数据类型 函数多返回值 defer机制 反射(reflect) 高性能HTTP Server 工程管理 编程规范 3. go 安装 3.1 windows go 下载 go 1.19.4 点击安装 配置环境变量 我的电脑右击---> 高级系统配置-----> 环境变量配置 配置 GOROOT为安装目录位置，我的是D:\\install\\go1.19.4 配置 命令路径 PATH ：D:\\install\\go1.19.4\\bin 3.2 UNIX/Linux/Mac OS X, 和 FreeBSD 安装 以下介绍了在UNIX/Linux/Mac OS X, 和 FreeBSD系统下使用源码安装方法： 官网地址：https://studygolang.com/dl Centos 8.2 配置 go 项目开发环境 $ wget https://studygolang.com/dl/golang/go1.13.8.linux-amd64.tar.gz $ tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz 3、将 /usr/local/go/bin 目录添加至PATH环境变量： $ vim /etc/profile #根目录 export GOROOT=/usr/local/go #bin目录 export GOBIN=$GOROOT/bin #工作目录 export GOPATH=/usr/local/gopath export PATH=$PATH:$GOPATH:$GOBIN:$GOROOT 保存并重启 $ . /etc/profile $ go env 4. go 学习网站 web应用开发 build-web-application-with-golang go语言圣经 5. go 开始 hello world package main import \"fmt\" func main() { fmt.Println(\"Hello, 世界\") } 运行.go文件 go run helloworld.go Hello, 世界 命令生成一个名为helloworld的可执行的二进制文件 go build helloworld.go $ ./helloworld Hello, 世界 获取/编译/安装 go get gopl.io/ch1/helloworld Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_1_GOPATH_and_GOROOT.html":{"url":"Go-Base/go_1_GOPATH_and_GOROOT.html","title":"go goroot 与 gopath 介绍","keywords":"","body":"Go GOROOT 与 GOPATH 介绍设置 GOPATH得作用go源码的组织方式归档文件存放的具体位置和规则Go GOROOT 与 GOPATH 介绍 GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径。 GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。 GOBIN：GO 程序生成的可执行文件（executable file）的路径。 设置 GOPATH得作用 你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。 我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。 go源码的组织方式 Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中. 一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。 代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。 每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。就像这样： import \"github.com/labstack/echo\" 归档文件存放的具体位置和规则 源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。 放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是 github.com/labstack/echo 那么执行命令 go install github.com/labstack/echo 生成的归档文件的相对目录就是 github.com/labstack， 文件名为 echo.a。 上面这个代码包导入路径还有另外一层含义，该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中。 归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。 用go env 可查看当前go环境变量。 GOPATH目录结构 goWorkSpace // (goWorkSpace为GOPATH目录) -- bin // golang编译可执行文件存放路径，可自动生成。 -- pkg // golang编译的.a中间文件存放路径，可自动生成。 -- src // 源码路径。按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令） goWorkSpace // goWorkSpace为GOPATH目录 -- bin -- myApp1 // 编译生成 -- myApp2 // 编译生成 -- myApp3 // 编译生成 -- pkg -- src -- common 1 -- common 2 -- common utils ... -- myApp1 // project1 -- models -- controllers -- others -- main.go -- myApp2 // project2 -- models -- controllers -- others -- main.go -- myApp3 // project3 -- models -- controllers -- others -- main.go Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_2_import.html":{"url":"Go-Base/go_2_import.html","title":"go 通过 import 导入包","keywords":"","body":"Go 通过 import 导入包1 单行导入2 多行导入3 使用别名4 使用点操作5. 包的初始化6. 包的匿名导入7. 导入的是路径还是包？8. 相对导入和绝对导入9. 包导入路径优先级Go 通过 import 导入包 1 单行导入 import \"fmt\" import \"sync\" 2 多行导入 import( \"fmt\" \"sync\" ) 3 使用别名 我们导入了两个具有同一包名的包时产生冲突，此时这里为其中一个包定义别名 import ( \"crypto/rand\" mrand \"math/rand\" // 将名称替换为mrand避免冲突 ) 我们导入了一个名字很长的包，为了避免后面都写这么长串的包名，可以这样定义别名 import hw \"helloworldtestmodule\" 防止导入的包名和本地的变量发生冲突，比如 path 这个很常用的变量名和导入的标准包冲突。 import pathpkg \"path\" 4 使用点操作 如里在我们程序内部里频繁使用了一个工具包，比如 fmt，那每次使用它的打印函数打印时，都要 包名+方法名。 对于这种使用高频的包，可以在导入的时，就把它定义会 \"自己人\"（方法是使用一个 . ），自己人的话，不分彼此，它的方法，就是我们的方法。 从此，我们打印再也不用加 fmt 了。 import . \"fmt\" func main() { Println(\"hello, world\") } 但这种用法，会有一定的隐患，就是导入的包里可能有函数，会和我们自己的函数发生冲突。 5. 包的初始化 每个包都允许有一个或多个的 init 函数，当这个包被导入时，会执行该包的这个 init 函数，做一些初始化任务。 对于 init 函数的执行有两点需要注意 init 函数优先于 main 函数执行 在一个包引用链中，包的初始化是深度优先的。比如，有这样一个包引用关系：main→A→B→C，那么初始化顺序为 C.init→B.init→A.init→main 6. 包的匿名导入 当我们导入一个包时，如果这个包没有被使用到，在编译时，是会报错的。 但是有些情况下，我们导入一个包，只想执行包里的 init 函数，来运行一些初始化任务，此时怎么办呢？ 可以使用匿名导入，用法如下，其中下划线为空白标识符，并不能被访问 // 注册一个PNG decoder import _ \"image/png\" 由于导入时，会执行 init 函数，所以编译时，仍然会将这个包编译到可执行文件中。 7. 导入的是路径还是包？ 当我们使用 import 导入 testmodule/foo 时，初学者，经常会问，这个 foo 到底是一个包呢，还是只是包所在目录名？ import \"testmodule/foo\" 为了得出这个结论，专门做了个试验（请看「第七点里的代码示例」），最后得出的结论是： 导入时，是按照目录导入。导入目录后，可以使用这个目录下的所有包。 出于习惯，包名和目录名通常会设置成一样，所以会让你有一种你导入的是包的错觉8. 相对导入和绝对导入 据我了解在 Go 1.10 之前，好像是不支持相对导入的，在 Go 1.10 之后才可以。 绝对导入：从 $GOPATH/src 或 $GOROOT 或者 $GOPATH/pkg/mod 目录下搜索包并导入 相对导入：从当前目录中搜索包并开始导入。就像下面这样 import ( \"./module1\" \"../module2\" \"../../module3\" \"../module4/module5\" ) 9. 包导入路径优先级 前面一节，介绍了三种不同的包依赖管理方案，不同的管理模式，存放包的路径可能都不一样，有的可以将包放在 GOPATH 下，有的可以将包放在 vendor 下，还有些包是内置包放在 GOROOT 下。 那么问题就来了，如果在这三个不同的路径下，有一个相同包名但是版本不同的包，我们导入的时候，是选择哪个进行导入呢？ 这就需要我们搞懂，在 Golang 中包搜索路径优先级是怎样的？ 这时候就需要区分，是使用哪种模式进行包的管理的。 如果使用 govendor 当我们导入一个包时，它会： 先从项目根目录的 vendor 目录中查找 然后从 $GOROOT/src 目录下查找 最后从 $GOPATH/src 目录下查找 都找不到的话，就报错。 为了验证这个过程，我在创建中创建一个 vendor 目录后，就开启了 vendor 模式了，我在 main.go 中随便导入一个包 pkg，由于这个包是我随便指定的，当然会找不到，找不到就会报错， Golang 会在报错信息中打印中搜索的过程，从这个信息中，就可以看到 Golang 的包查找优先级了。 如果使用 go modules 你导入的包如果有域名，都会先在 $GOPATH/pkg/mod 下查找，找不到就连网去该网站上寻找，找不到或者找到的不是一个包，则报错。 而如果你导入的包没有域名（比如 \"fmt\"这种），就只会到 $GOROOT 里查找。 还有一点很重要，当你的项目下有 vendor 目录时，不管你的包有没有域名，都只会在 vendor 目录中想找。 通常vendor 目录是通过 go mod vendor 命令生成的，这个命令会将项目依赖全部打包到你的项目目录下的 verdor 文件夹中。 参考： 2020重学Go系列：25. Go 语言中关于包导入必学的 8 个知识点 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_3_goproxy_configuration.html":{"url":"Go-Base/go_3_goproxy_configuration.html","title":"go 代理加速配置","keywords":"","body":"Go 代理加速配置1. Go 版本是 1.13 及以上 （推荐）设置不走 proxy 的私有仓库，多个用逗号相隔（可选）2. Go 版本是 1.12 及以下2.1. Bash (Linux or macOS)2.2 PowerShell (Windows)3. 测试Go 代理加速配置 1. Go 版本是 1.13 及以上 （推荐） go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct 设置不走 proxy 的私有仓库，多个用逗号相隔（可选） go env -w GOPRIVATE=*.corp.example.com 设置完上面几个环境变量后，您的 go 命令将从公共代理镜像中快速拉取您所需的依赖代码了。私有库的支持请看这里。 2. Go 版本是 1.12 及以下 2.1. Bash (Linux or macOS) 2.1.1 第一种方式代理配置 启用 Go Modules 功能 export GO111MODULE=on #配置 GOPROXY 环境变量 export GOPROXY=https://goproxy.io 2.1.2 第二种方式代理配置 或者，根据文档可以把上面的命令写到.profile或.bash_profile文件中长期生效。 echo \"export GO111MODULE=on\" >> ~/.profile echo \"export GOPROXY=https://goproxy.io\" >> ~/.profile source ~/.profile 2.1.3 第三种方式代理配置 # 启用 Go Modules 功能 go env -w GO111MODULE=on # 配置 GOPROXY 环境变量，以下三选一 # 1. 官方 go env -w GOPROXY=https://goproxy.io # 2. 七牛 CDN go env -w GOPROXY=https://goproxy.cn # 3. 阿里云 go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/ 2.2 PowerShell (Windows) # 启用 Go Modules 功能 $env:GO111MODULE=\"on\" # 配置 GOPROXY 环境变量 $env:GOPROXY=\"https://goproxy.io\" 右键 我的电脑 -> 属性 -> 高级系统设置 -> 环境变量 在 “[你的用户名]的用户变量” 中点击 ”新建“ 按钮 在 “变量名” 输入框并新增 “GOPROXY” 在对应的 “变量值” 输入框中新增 “https://goproxy.io” 最后点击 “确定” 按钮保存设置 3. 测试 go get github.com/gin-gonic/gin go get github.com/astaxie/beego 参考： 官网文档：https://goproxy.io/zh/docs/introduction.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_4_Modules.html":{"url":"Go-Base/go_4_Modules.html","title":"go modules 管理包工具","keywords":"","body":"Go Modules 管理包工具1. 背景2. 简介2.1 设置 GO111MODULE2.2 Mod Cache 路径2.3 Go Mod 命令3. 创建 module3.1 创建项目3.2 添加依赖项3.3 升级依赖项4. 推送仓库4.1 发布版本4.2 语义化版本5. vendor目录5.1 vendor 目录有两个目的：5.2 生成vendorGo Modules 管理包工具 @[toc] 1. 背景 发展历史： 在 1.5 版本之前，所有的依赖包都是存放在 GOPATH 下，没有版本控制。这个类似 Google 使用单一仓库来管理代码的方式。这种方式的最大的弊端就是无法实现包的多版本控制，比如项目 A 和项目 B 依赖于不同版本的 package，如果 package 没有做到完全的向前兼容，往往会导致一些问题。 1.5 版本推出了 vendor 机制。所谓 vendor 机制，就是每个项目的根目录下可以有一个 vendor 目录，里面存放了该项目的依赖的 package。go build 的时候会先去 vendor 目录查找依赖，如果没有找到会再去GOPATH 目录下查找。 1.9 版本推出了实验性质的包管理工具 dep，这里把 dep 归结为 Golang 官方的包管理方式可能有一些不太准确。关于 dep 的争议颇多，比如为什么官方后来没有直接使用 dep 而是弄了一个新的 modules，具体细节这里不太方便展开。 1.11 版本推出 modules 机制，简称 mod。modules 的原型其实是 vgo，关于 vgo，可以自行搜索。 除此之外，社区也一直在有几个活跃的包管理工具，使用广泛且具有代表性的主要有下面几个： godep glide govendor 2. 简介 在 Java 的项目中，有 Maven 和 Gradle 这些很好用的依赖版本管理工具，简直不要太方便了，但是在 Golang 的项目中，之前的 Golang 官方并没有提供版本管理工具，我们以前用 go get 获取依赖其实是有潜在危险的，因为我们不确定最新版依赖是否会破坏掉我们项目对依赖包的使用方式，即当前项目可能会出现不兼容最新依赖包的问题。之后官方出了一个 vendor 机制，将项目依赖的包都放在该目录中，但这也并没有很好地管理依赖的版本。之后官方出了一个准官方版本管理工具 go dep，这也算是 go modules 的前身了吧。 2.1 设置 GO111MODULE Go Modules 在 Go 1.11 及 Go 1.12 中有三个模式，根据环境变量 GO111MODULE 定义： 默认模式（未设置该环境变量或 GO111MODULE=auto）：Go 命令行工具在同时满足以下两个条件时使用 Go Modules：当前目录不在 GOPATH/src/ 下；在当前目录或上层目录中存在 go.mod 文件。 GOPATH 模式（GO111MODULE=off）：Go 命令行工具从不使用 Go Modules。相反，它查找 vendor 目录和GOPATH 以查找依赖项。 Go Modules 模式（GO111MODULE=on）：Go 命令行工具只使用 Go Modules，从不咨询GOPATH。GOPATH不再作为导入目录，但它仍然存储下载的依赖项（GOPATH/pkg/mod/）和已安装的命令（GOPATH/bin/），只移除了 GOPATH/src/。 Go 1.13 默认使用 Go Modules 模式，所以以上内容在 Go 1.13 发布并在生产环境中使用后都可以忽略。 2.2 Mod Cache 路径 默认在$GOPATH/pkg 下面： $ echo $GOPATH/pkg/mod /usr/local/gopath/pkg/mod 项目下载下来的文件形式 $ ls /usr/local/gopath/pkg/mod/cache/download/github.com/go-sql-driver/mysql/@v/ list list.lock v1.5.0.info v1.5.0.lock v1.5.0.mod v1.5.0.zip v1.5.0.ziphash 2.3 Go Mod 命令 $ go mod Usage: go mod [arguments] The commands are: download download modules to local cache (下载依赖的module到本地cache)) edit edit go.mod from tools or scripts (编辑go.mod文件) graph print module requirement graph (打印模块依赖图)) init initialize new module in current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件)) tidy add missing and remove unused modules (增加丢失的module，去掉未用的module) vendor make vendored copy of dependencies (将依赖复制到vendor下) verify verify dependencies have expected content (校验依赖) why explain why packages or modules are needed (解释为什么需要依赖) 3. 创建 module 3.1 创建项目 在默认情况下，$GOPATH 默认情况下是不支持 go mudules 的，我们需要在项目目录下手动执行以下命令： $ export GO111MODULE=on 为了配合 go modules 机制，我们 $GOPATH 以外的目录创建一个 testmod 的包： $ mkdir testmod $ cd testmod $ go mod init github.com/ghostwritten/testmod go: creating new go.mod: module github.com/ghostwritten/testmod 3.2 添加依赖项 $ vim main.go package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 } $ ls go.mod main.go $ cat go.mod module github.com/ghostwritten/testmod go 1.13 $ go build go: finding github.com/gin-gonic/gin v1.6.3 go: downloading github.com/gin-gonic/gin v1.6.3 go: extracting github.com/gin-gonic/gin v1.6.3 $ cat go.mod module github.com/ghostwritten/testmod go 1.13 require github.com/gin-gonic/gin v1.6.3 #新依赖包 3.3 升级依赖项 3.3.1 依赖列表 $ go list -m all #第一种方式 github.com/ghostwritten/testmod github.com/davecgh/go-spew v1.1.1 github.com/gin-contrib/sse v0.1.0 github.com/gin-gonic/gin v1.6.3 github.com/go-playground/assert/v2 v2.0.1 ...... $ go list -m -json #第二种方式 { \"Path\": \"github.com/ghostwritten/testmod\", \"Main\": true, \"Dir\": \"/root/go/testmod\", \"GoMod\": \"/root/go/testmod/go.mod\", \"GoVersion\": \"1.13\" } 3.3.2 查看依赖的版本历史 go list -m -versions github.com/gin-gonic/gin github.com/gin-gonic/gin v1.1.1 v1.1.2 v1.1.3 v1.1.4 v1.3.0 v1.4.0 v1.5.0 v1.6.0 v1.6.1 v1.6.2 v1.6.3 3.3.3 更新到上个版本 $ go get github.com/gin-gonic/gin@v1.1.4 $ go list -m all // 看到了版本变化 github.com/gin-gonic/gin v1.1.4 3.3.4 或者可以使用 go mod 来进行版本的切换 $ go mod edit -require=\"github.com/gin-gonic/gin@v1.1.4\" // 修改 go.mod 文件 $ go tidy //下载更新依赖 3.3.5 删除未使用的依赖项 go mod tidy 4. 推送仓库 $ git init $ git add * $ git commit -am \"First commit\" 4 git git remote add origin http://gitlab.com/ghostwritten/testmod.git $ git push -u origin master 4.1 发布版本 发布一下该项目的版本 $ git tag v1.0.0 $ git push --tags 如果更新创建一条 v1 分支，以便我们在其它分支写代码不会影响到 v1.0.0 版本 $ git checkout -b v1 $ git push -u origin v1 4.2 语义化版本 什么是语义化版本？语义化版本是一套由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立的约定。在这套约定下，语义化版本号及其更新方式包含了很多有用的信息。 语义化版本号格式为：X.Y.Z（主版本号.次版本号.修订号），使用方法如下： 进行不向下兼容的修改时，递增主版本号。 API 保持向下兼容的新增及修改时，递增次版本号。 修复问题但不影响 API 时，递增修订号。 5. vendor目录 5.1 vendor 目录有两个目的： 可以使用依赖项的确切版本用来构建。 即使原始副本消失，也能保证这些依赖项是可用的。 而模块现在有了更好的机制来实现这两个目的： 通过在 go.mod 文件中指定依赖项的确切版本。 可用性则由缓存代理（$GOPROXY）实现。 5.2 生成vendor $ go mod vendor 参考： https://www.cnblogs.com/sunsky303/p/10710637.html https://objcoding.com/2018/09/13/go-modules/ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_5_type.html":{"url":"Go-Base/go_5_type.html","title":"go 基本类型","keywords":"","body":"go 基本类型1. 基本类型2. 基本类型应用go 基本类型 1. 基本类型 类型 长度(字节) 默认值 说明 bool 1 false byte 1 0 uint8 rune 4 0 Unicode Code Point, int32 int, uint 4或8 0 32 或 64 位 int8, uint8 1 0 -128 ~ 127, 0 ~ 255，byte是uint8 的别名 int16, uint16 2 0 -32768 ~ 32767, 0 ~ 65535 int32, uint32 4 0 -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 int64, uint64 8 0 float32 4 0.0 float64 8 0.0 complex64 8 complex128 16 uintptr 4或8 以存储指针的 uint32 或 uint64 整数 array 值类型 struct 值类型 string “” UTF-8 字符串 slice nil 引用类型 map nil 引用类型 channel nil 引用类型 interface nil 接口 function nil 函数 支持八进制、 六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。 a, b, c, d := 071, 0x1F, 1e9, math.MinInt16 空指针值 nil，而非C/C++ NULL。 2. 基本类型应用 bool:只能存true和false uint uint8 uint16 uint32 uint64 uintptr byte // uint8 的别名 ：字符类型 rune // int32 的别名，代表一个Unicode码，用UTF-8 进行编码。 rune 类型在什么时候使用呢？ 例如需要遍 历字符串中的字符。可以循环每个字节（仅在使用US ASCII 编码字符串时与字符等价， 而它们在Go 中不存在！）。因此为了获得实际的字符，需要使用rune 类型。 string rune byte 的关系 在Go当中 string底层是用byte数组存的，并且是不可以改变的。 例如： package main import \"fmt\" func main() { s := \"Go编程\" fmt.Println(len(s)) } 输出结果应该是8因为中文字符是用3个字节存的。 package main import \"fmt\" func main() { s := len(string(rune('编'))) fmt.Println(s) } 输出结果是3 如果想要获得我们想要的情况的话，需要先转换为rune切片再使用内置的len函数 package main import \"fmt\" func main() { s := \"Go编程\" fmt.Println(len([]rune(s))) } 输出结果是4 所以用string存储unicode的话，如果有中文，按下标是访问不到的，因为你只能得到一个byte。 要想访问中文的话，还是要用rune切片，这样就能按下表访问。 与导入语句一样，变量的定义“打包”在一个语法块中。 int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。 值类型： 变量直接存储值，内存通常在栈中分配。 获取变量的地址，用&，比如： var a int, 获取a的地址：&a 基本数据类型int、float、bool、string以及数组和struct。 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.3.2.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_6_const.html":{"url":"Go-Base/go_6_const.html","title":"go const 定义常量","keywords":"","body":"Go const 定义常量1. 前言2. 常量初始化3. 枚举Go const 定义常量 1. 前言 常量的定义与变量类似，只不过使用 const 关键字，表示只读不能修改。 const World = “世界” 常量值必须是编译期可确定的字符、字符串、布尔或数字类型的值。 常量不能使用 “:=” 语法定义。加粗样式 数值常量 数值常量是高精度的值 。 一个未指定类型的常量由上下文来决定其类型。 （int 可以存放最大64位的整数，根据平台不同有时会更少。） 2. 常量初始化 package main const x, y int = 1, 2 // 多常量初始化 const s = \"Hello, World!\" // 类型推断 const ( //常量组 a, b = 10, 100 c bool = false ) func main() { const str = \"xxx\" // 未使用的局部常量不会引发编译错误。 } 在常量组中，如不提供类型和初始化值，那么视作与上一个常量相同。 package main import ( \"fmt\" ) const ( s = \"abc\" x // x = \"abc\" ) func main() { fmt.Println(s) fmt.Println(x) } 输出结果： abc abc 常量值还可以是 len、cap、unsafe.Sizeof 等编译期可确定结果的函数返回值。 const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) 如果常量类型足以存储初始化值，那么不会引发溢出错误。 package main import ( \"fmt\" \"unsafe\" ) const ( a = \"hello world\" b = len(a) c = unsafe.Sizeof(b) ) func main() { fmt.Println(a, b, c) } 输出结果： hello world 11 8 3. 枚举 iota 可以被用作枚举值： iota，特殊常量，可以认为是一个可以被编译器修改的常量。 在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。 关键字 iota 定义常量组中从 0 开始按行计数的自增枚举值。 package main import ( \"fmt\" ) const ( Sunday = iota Monday //通常省略后续行表达式 Tuesday Wednesday Thursday Friday Saturday ) func main() { fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday) } 输出结果： 0 1 2 3 4 5 6 package main import ( \"fmt\" ) const ( _ = iota // iota = 0 KB int64 = 1 在同一常量组中，可以提供多个 iota，它们各自增长。 package main import ( \"fmt\" ) const ( A, B = iota, iota 如果 iota 自增被打断，须显式恢复。 package main import ( \"fmt\" ) const ( A = iota //0 B // 1 C = \"c\" //c D // c，与上 相同。 E = iota // 4，显式恢复。注意计数包含了 C、D 两 。 F // 5 ) func main() { fmt.Println(A, B, C, D, E, F) } 输出结果： 0 1 c c 4 5 可通过自定义类型来实现枚举类型限制。 package main type Color int const ( Black Color = iota Red Blue ) func test(c Color) {} func main() { c := Black test(c) // x := 1 // test(x) // ./main.go:18:6: cannot use x (type int) as type Color in argument to test test(1) // 常量会被编译器自动转换。 } 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.2.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_7_iota.html":{"url":"Go-Base/go_7_iota.html","title":"go 定义常量之 iota","keywords":"","body":"Go 定义常量之 iota1. iota 只能在常量的表达式中使用2. 每次 const 出现时，都会让 iota 初始化为03. 自定义类型4. 可跳过的值5. 位掩码表达式6. 定义数量级7. 定义在一行的情况8. 中间插队Go 定义常量之 iota 1. iota 只能在常量的表达式中使用 fmt.Println(iota) 编译错误： undefined: iota 2. 每次 const 出现时，都会让 iota 初始化为0 const a = iota // a=0 const ( b = iota //b=0 c //c=1 ) 3. 自定义类型 自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。 type Stereotype int const ( TypicalNoob Stereotype = iota // 0 TypicalHipster // 1 TypicalUnixWizard // 2 TypicalStartupFounder // 3 ) 4. 可跳过的值 设想你在处理消费者的音频输出。音频可能无论什么都没有任何输出，或者它可能是单声道，立体声，或是环绕立体声的。 这可能有些潜在的逻辑定义没有任何输出为 0，单声道为 1，立体声为 2，值是由通道的数量提供。 所以你给 Dolby 5.1 环绕立体声什么值。 一方面，它有6个通道输出，但是另一方面，仅仅 5 个通道是全带宽通道（因此 5.1 称号 - 其中 .1 表示的是低频效果通道）。 不管怎样，我们不想简单的增加到 3。 我们可以使用下划线跳过不想要的值。 type AudioOutput int const ( OutMute AudioOutput = iota // 0 OutMono // 1 OutStereo // 2 _ _ OutSurround // 5 ) 5. 位掩码表达式 type Allergen int const ( IgEggs Allergen = 1 这个工作是因为当你在一个 const 组中仅仅有一个标示符在一行的时候，它将使用增长的 iota 取得前面的表达式并且再运用它，。在 Go 语言的 spec 中， 这就是所谓的隐性重复最后一个非空的表达式列表。 如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值 00010011，它对应十进制的 19。 fmt.Println(IgEggs | IgChocolate | IgShellfish) // output: // 19 6. 定义数量级 type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 7. 定义在一行的情况 const ( Apple, Banana = iota + 1, iota + 2 Cherimoya, Durian Elderberry, Fig ) iota 在下一行增长，而不是立即取得它的引用。 // Apple: 1 // Banana: 2 // Cherimoya: 2 // Durian: 3 // Elderberry: 3 // Fig: 4 8. 中间插队 const ( i = iota j = 3.14 k = iota l ) 那么打印出来的结果是 i=0,j=3.14,k=2,l=3 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_8_type.html":{"url":"Go-Base/go_8_type.html","title":"go type 声明变量","keywords":"","body":"Go type 声明变量1. type 定义Go type 声明变量 1. type 定义 新类型声明格式：(是类型的组合) package main import ( \"fmt\" \"reflect\" ) type bigint int64 func main() { var x bigint = 100 fmt.Printf(\"x 的值是：%v\\n\", x) fmt.Printf(\"x 的类型是：%v\\n\", reflect.TypeOf(x)) type smallint int8 var y smallint = 1 fmt.Printf(\"y 的值是：%v\\n\", y) fmt.Printf(\"y 的类型是：%v\\n\", reflect.TypeOf(y)) } [root@localhost struct]# go run stru1.go x 的值是：100 x 的类型是：main.bigint y 的值是：1 y 的类型是：main.smallint 新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息。除非目标类型是未命名类型，否则必须显式转换。 package main import ( \"fmt\" \"reflect\" ) type bigint int64 type myslice []int func main() { x := 1234 var b bigint = bigint(x) // 必须显式转换，除非是常量。 var b2 int64 = int64(b) fmt.Printf(\"b2 的值是：%v , b2 的类型是：%v\\n\", b2, reflect.TypeOf(b2)) var s myslice = []int{1, 2, 3} // 未命名类型，隐式转换。 var s2 []int = s fmt.Printf(\"s2 的值是：%v , s2 的类型是：%v\\n\", s2, reflect.TypeOf(s2)) } [root@localhost struct]# go run stru2.go b2 的值是：1234 , b2 的类型是：int64 s2 的值是：[1 2 3] , s2 的类型是：[]int Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_9_variable.html":{"url":"Go-Base/go_9_variable.html","title":"go 定义变量","keywords":"","body":"Go 定义变量1. 定义变量2. 初始化变量3. Go 语言变量作用域4. 局部变量5. 全局变量6. 形式参数6.1 全局：6.2 局部：Go 定义变量 1. 定义变量 var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。 2. 初始化变量 使用关键字 var 定义变量，自动初始化为零值。如果提供初始化值，可省略变量类型，由编译器自动推断。 package main var x int var f float32 = 1.6 var s = \"abc\" func main() { } 一次性定义多个变量 package main var x, y, z int var s, n = \"abc\", 123 var ( a int b float32 ) func main() { n, s := 0x1234, \"Hello, World!\" println(x, s, n) } 输出结果： 0 Hello, World! 4660 多变量赋值时，先计算所有相关值，然后再从左到右依次赋值。 package main import \"fmt\" func main() { data, i := [3]int{0, 1, 2}, 0 i, data[i] = 2, 100 // (i = 0) -> (i = 2), (data[0] = 100) fmt.Println(i, data) } 输出结果： 2 [100 1 2] 变量定义可以包含初始值，每个变量对应一个。 package main var i, j int = 1, 2 func main() { } 如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。 package main var c, python, java = true, false, \"no!\" func main() { } 短声明变量 在函数内部，可以使用更简略的 “:=” 方式定义变量。”:=” 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。 package main import ( \"fmt\" ) var c, python, java = true, false, \"no!\" func main() { k := 3 c, python, java := false, true, \"yes!\" fmt.Println(c, python, java, k) //注意检查，是定义新的局部变量，还是修改全局变量。该方式容易造成错误！ } 输出结果： false true yes! 3 函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， “:=” 结构不能使用在函数外。 特殊只写变量 “_”，用于忽略值占位。 package main func test() (int, string) { return 1, \"abc\" } func main() { _, s := test() println(s) } 输出结果： abc 编译器会将未使 的局部变量当做错误。 package main var s string // 全局变量没问题。 func main() { i := 0 // ./main.go:6:7: i declared and not used (可使 \"_ = i\" 规避) } 注意重新赋值与定义新同名变量的区别。 package main func main() { s := \"abc\" println(&s) s, y := \"hello\", 20 // 重新赋值: 与前 s 在同 层次的代码块中，且有新的变量被定义。 println(&s, y) // 通常函数多返回值 err 会被重复使用。 { s, z := 1000, 30 // 定义新同名变量: 不在同 层次代码块。 println(&s, z) } } 输出结果: 0xc42003df60 0xc42003df60 20 0xc42003df58 30 3. Go 语言变量作用域 作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。 Go 语言中变量可以在三个地方声明： 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数 接下来让我们具体了解局部变量、全局变量和形式参数。 4. 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 以下实例中 main() 函数使用了局部变量 a, b, c： package main import \"fmt\" func main() { /* 声明局部变量 */ var a, b, c int /* 初始化参数 */ a = 10 b = 20 c = a + b fmt.Printf(\"结果： a = %d, b = %d and c = %d\\n\", a, b, c) } 输出结果： 结果： a = 10, b = 20 and c = 30 5. 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。 全局变量可以在任何函数中使用，以下实例演示了如何使用全局变量： package main import \"fmt\" /* 声明全局变量 */ var g int func main() { /* 声明局部变量 */ var a, b int /* 初始化参数 */ a = 10 b = 20 g = a + b fmt.Printf(\"结果： a = %d, b = %d and g = %d\\n\", a, b, g) } 输出结果： 结果： a = 10, b = 20 and g = 30 Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。实例如下： package main import \"fmt\" /* 声明全局变量 */ var g int = 20 func main() { /* 声明局部变量 */ var g int = 10 fmt.Printf(\"结果： g = %d\\n\", g) } 输出结果： 结果： g = 10 6. 形式参数 形式参数会作为函数的局部变量来使用。实例如下： package main import \"fmt\" /* 声明全局变量 */ var a int = 20 func main() { /* main 函数中声明局部变量 */ var a int = 10 var b int = 20 var c int = 0 fmt.Printf(\"main()函数中 a = %d\\n\", a) c = sum(a, b) fmt.Printf(\"main()函数中 c = %d\\n\", c) } /* 函数定义-两数相加 */ func sum(a, b int) int { fmt.Printf(\"sum() 函数中 a = %d\\n\", a) fmt.Printf(\"sum() 函数中 b = %d\\n\", b) return a + b } 输出结果： main()函数中 a = 10 sum() 函数中 a = 10 sum() 函数中 b = 20 main()函数中 c = 30 不同类型的局部和全局变量默认值： 6.1 全局： package main import \"fmt\" var b bool var i int var i8 int8 var i16 int16 var i32 int32 var i64 int64 var ui uint var ui8 uint8 var ui16 uint16 var ui32 uint32 var ui64 uint64 var f32 float32 var f64 float64 var s string func main() { fmt.Printf(\"全局变量: bool 默认值：%v\\n\", b) fmt.Printf(\"全局变量: int 默认值：%v\\n\", i) fmt.Printf(\"全局变量: int8 默认值：%v\\n\", i8) fmt.Printf(\"全局变量: int16 默认值：%v\\n\", i16) fmt.Printf(\"全局变量: int32 默认值：%v\\n\", i32) fmt.Printf(\"全局变量: int64 默认值：%v\\n\", i64) fmt.Printf(\"全局变量: int64 默认值：%v\\n\", i64) fmt.Printf(\"全局变量: uint 默认值：%v\\n\", ui) fmt.Printf(\"全局变量: uint8 默认值：%v\\n\", ui8) fmt.Printf(\"全局变量: uint16 默认值：%v\\n\", ui16) fmt.Printf(\"全局变量: uint32 默认值：%v\\n\", ui32) fmt.Printf(\"全局变量: uint64 默认值：%v\\n\", ui64) fmt.Printf(\"全局变量: uint64 默认值：%v\\n\", ui64) fmt.Printf(\"全局变量: float32 默认值：%v\\n\", f32) fmt.Printf(\"全局变量: float64 默认值：%v\\n\", f64) fmt.Printf(\"全局变量: string 默认值：%v\\n\", s) } 输出结果： 全局变量: bool 默认值：false 全局变量: int 默认值：0 全局变量: int8 默认值：0 全局变量: int16 默认值：0 全局变量: int32 默认值：0 全局变量: int64 默认值：0 全局变量: int64 默认值：0 全局变量: uint 默认值：0 全局变量: uint8 默认值：0 全局变量: uint16 默认值：0 全局变量: uint32 默认值：0 全局变量: uint64 默认值：0 全局变量: uint64 默认值：0 全局变量: float32 默认值：0 全局变量: float64 默认值：0 全局变量: string 默认值： 6.2 局部： package main import \"fmt\" func main() { var b bool var i int var i8 int8 var i16 int16 var i32 int32 var i64 int64 var ui uint var ui8 uint8 var ui16 uint16 var ui32 uint32 var ui64 uint64 var f32 float32 var f64 float64 var s string fmt.Printf(\"局部变量: bool 默认值：%v\\n\", b) fmt.Printf(\"局部变量: int 默认值：%v\\n\", i) fmt.Printf(\"局部变量: int8 默认值：%v\\n\", i8) fmt.Printf(\"局部变量: int16 默认值：%v\\n\", i16) fmt.Printf(\"局部变量: int32 默认值：%v\\n\", i32) fmt.Printf(\"局部变量: int64 默认值：%v\\n\", i64) fmt.Printf(\"局部变量: int64 默认值：%v\\n\", i64) fmt.Printf(\"局部变量: uint 默认值：%v\\n\", ui) fmt.Printf(\"局部变量: uint8 默认值：%v\\n\", ui8) fmt.Printf(\"局部变量: uint16 默认值：%v\\n\", ui16) fmt.Printf(\"局部变量: uint32 默认值：%v\\n\", ui32) fmt.Printf(\"局部变量: uint64 默认值：%v\\n\", ui64) fmt.Printf(\"局部变量: uint64 默认值：%v\\n\", ui64) fmt.Printf(\"局部变量: float32 默认值：%v\\n\", f32) fmt.Printf(\"局部变量: float64 默认值：%v\\n\", f64) fmt.Printf(\"局部变量: string 默认值：%v\\n\", s) } 输出结果： 局部变量: bool 默认值：false 局部变量: int 默认值：0 局部变量: int8 默认值：0 局部变量: int16 默认值：0 局部变量: int32 默认值：0 局部变量: int64 默认值：0 局部变量: int64 默认值：0 局部变量: uint 默认值：0 局部变量: uint8 默认值：0 局部变量: uint16 默认值：0 局部变量: uint32 默认值：0 局部变量: uint64 默认值：0 局部变量: uint64 默认值：0 局部变量: float32 默认值：0 局部变量: float64 默认值：0 局部变量: string 默认值： 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.1.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_10_operator.html":{"url":"Go-Base/go_10_operator.html","title":"go 运算符总结","keywords":"","body":"Go 运算符总结1.算数运算符2.关系运算符3.逻辑运算符4.位运算符5.赋值运算符6.其他运算符Go 运算符总结 1.算数运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 2.关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False = 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 3.逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 4.位运算符 位运算符对整数在内存中的二进制位进行操作。假定 A 为60，B 为13 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 111100 & 1101 二进制为 0000 1100 | 按位或运算符\"|\"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 111100 | 1101 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 > 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 演示示例 [root@localhost yunsuan]# cat test1.go package main import \"fmt\" func main() { var a int = 60 //二进制是：111100 var b int = 13 //二进制是：001101 fmt.Printf(\"%b\\n%d\\n\",a&b,a&b) //二进制是：1100,对应的十进制是12。说明&进行的是上下对应位的与操作 fmt.Printf(\"%b\\n%d\\n\",a|b,a|b) //二进制是：111101,对应的十进制是61。说明&进行的是上下对应位的或操作 fmt.Printf(\"%b\\n%d\\n\",a^b,a^b) //二进制是：110001,对应的十进制是49。^位运算符是上下对应位不同时，值为1 } [root@localhost yunsuan]# go run test1.go 1100 12 111101 61 110001 49 左移右移运算符示例（实现计算器存储单位）： [root@localhost yunsuan]# cat test2.go package main import \"fmt\" const ( KB float64 = 1 5.赋值运算符 下表列出了所有Go语言的赋值运算符。假定 A 为21 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A 将 A 赋值给 C，结果：21 += 相加后再赋值 C += A 等于 C = C + A，结果：42 -= 相减后再赋值 C -= A 等于 C = C - A，结果：21 *= 相乘后再赋值 C *= A 等于 C = C * A，结果：441 /= 相除后再赋值 C /= A 等于 C = C / A，结果：21 %= 求余后再赋值 C %= A 等于 C = C % A，结果：0//不记入计算 >= 右移后赋值 C >>= 2 等于 C = C >> 2，结果：21 &= 按位与后赋值 C &= 2 等于 C = C & 2，结果：0 10101 & 10 =0 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2，结果：2 10101 ^ 10 = 00010 = 按位或后赋值 C |= 2 等于 C = C | 2，结果：2 10101 | 10 = 010 6.其他运算符 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 内存地址和指针的示例：打印变量类型用%T [root@localhost yunsuan]# cat test3.go package main import \"fmt\" func main() { var a int = 4 var b int32 var c float32 var ptr *int fmt.Printf(\"a 变量类型为 = %T\\n\", a ) //输出变量类型%T fmt.Printf(\"b 变量类型为 = %T\\n\", b ) fmt.Printf(\"c 变量类型为 = %T\\n\", c ) ptr = &a fmt.Printf(\"a 的内存地址为 = %p\",ptr) //go里面的内存块地址通常都是用十六进制表示的，因此输出：0x10414020a fmt.Printf(\"*ptr 为 %d\\n\", *ptr) //这是个指向a的内存地址的指针，因此输出：4 } [root@localhost yunsuan]# go run test3.go a 变量类型为 = int b 变量类型为 = int32 c 变量类型为 = float32 a 的内存地址为 = 0xc000082010*ptr 为 4 7.运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 7 ^ ! 6 * / % > & &^ 5 + - | ^ 4 == != = > 3 参考： https://www.runoob.com/go/go-operators.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_11_pointer_1.html":{"url":"Go-Base/go_11_pointer_1.html","title":"go 指针概念 1","keywords":"","body":"Go 指针概念【1】1. 基本类型指针的理解2. 引用类型指针的理解3. 值类型和引用类型4. 引用类型5. 栈内存和堆内存的区别6. &和*的意思7. 关于函数Go 指针概念【1】 1. 基本类型指针的理解 先看这两行代码。 var n1 int = 666 fmt.Println(n1)//结果:666 fmt.Printf(\"%p\\n\"，n1)//结果:%!p(int=666)，说明不是一个地址，就是一个值 内存分布图如下。 再看看这样两行代码，这里用到了&。 var n1 int = 1 //表示取n1的地址 fmt.Println(&n1)//结果:0xc00000a0b8 fmt.Printf(\"%p\\n\"，&n1)//结果:0xc00000a0b8 如图所示。 2. 引用类型指针的理解 先看这样的代码。 var studentList = []string{\"张三\"， \"李四\"}//一个切片 fmt.Println(studentList) //结果:[张三 李四] fmt.Printf(\"%p\\n\"， studentList) //结果:0xc0000044a0 //去地址 fmt.Printf(\"%p\\n\"， &studentList) //结果:0xc0000044a0 内存分布图如下。 3. 值类型和引用类型 值类型 在Go中，值类型主要有。 int，float，bool，string，数组，struct(结构体) 内存分布大致如下。 注:像字符串，数组，结构体这些属于连续存储，变量指向的是它们的第一个地址，剩下的会根据长度计算。 4. 引用类型 在Go中，引用类型主要有。 切片(slice)，map，管道(chan) 内存分布大致如下。 5. 栈内存和堆内存的区别 栈内存在存储上，只能存一些简单的东西，比如数字了，字符了，浮点数了之类的，但是栈内存分配的内存程序员不用回收，由系统自己回收，并且性能很高。 堆内存在存储上就比较丰富了，随便存，像map，随便塞，但是堆内存分配的内存需要程序员自己回收，典型例子，C++，如果语言由GC由GC回收，性能稍弱那么一点点点....，但是人家能随便存啊，多随便。 6. &和*的意思 &叫做取地址符。 *叫做收地址符。 示例 var c int//int是一个整体，说明c这个变量只能接收int类型的 *int是一个整体，表示c这个变量只能接收int类型的地址。 代码 package main import \"fmt\" func main() { var c *int var d int = 1 //c = d//错误需要的是d的地址 c = &d fmt.Println(c) } 执行结果。 可以看到打印的也是一个地址，但是内存图还是基本类型图。 如果要打印c的值，直接*c就好了，取得就是地址里面对应得值了。 fmt.Println(*c) 7. 关于函数 我们一直在强调，操作只会操作栈上面的值，函数同理。 package main import \"fmt\" func say1(x int) { //x int 相当于隐藏了一行代码 //隐藏的代码时 var x int = x，一定要记住这个 fmt.Printf(\"say1:%p\\n\"， x) } func say2(x *int) { //隐藏的代码是 var x *int = x，x是一个地址 fmt.Printf(\"say2:%p\\n\"， x) } func say3(x []int) { //隐藏的代码是 var x []int = x，因为x是引用类型，所以x是一个地址 fmt.Printf(\"say3:%p\\n\"， x) } func main() { say1(1)//栈上面是1，所以传进去就是1 var x1 = 1 say2(&x1)//say只能接收整数地址 var x2 = []int{1， 1} say3(x2)//x2是引用类型，所以传进去的时候就是地址，栈上面的就是地址 } 执行结果。 参考： https://mp.weixin.qq.com/s/M4VHGdgGhuU4OYBrkZb2aw Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_11_pointer_2.html":{"url":"Go-Base/go_11_pointer_2.html","title":"go 指针应用实践","keywords":"","body":"Go 指针应用实践1. 前言2. 什么是指针3. 如何使用指针4. Go 空指针（nil）5. Go 指针数组Go 指针应用实践 1. 前言 指针概念在 Go 语言中被拆分为两个核心概念： 类型指针，允许对这个指针类型的数据进行修改。传递数据使用指针，而无须拷贝 数据。类型指针不能进行偏移和运算。 切片，由指向起始元素的原始指针、元素数量和容量组成。 受益于这样的约束和拆分， Go 语言的指针类型变量拥有指针的高效访问，但又不会 发生指针偏移，从而避免非法修改关键性数据问题。同时， 垃圾回收也比较容易对不会发 生偏移的指针进行检索和回收。 切片比原始指针具备更强大的特性， 更为安全。切片发生越界时，运行时会报出岩机，并打出堆枝，而原始指针只会崩溃。 要明白指针，需要知道几个概念：指针地址、指针类型和指针取值。 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。 Go 语言中 使用“＆” 操作符放在变量前面对变量进行“取地址”操作。 格式如下： ptr : = &v II v 的类型为 T 其中 v代表被取地址的变量，被取地址的V使用 阳变量进行接收，p仕的类型就为川T”， 称做 T 的指针类型。 “＊”代表指针 我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。 Golang 支持指针类型 T，指针的指针 **T，以及包含包名前缀的 .T。 默认值 nil，没有 NULL 常量。 操作符 \"&\" （取地址符） 取变量地址 \"*\" （取值符）透过指针访问目标对象。 不支持指针运算，不支持 \"->\" 运算符，直接用 \".\" 访问目标成员。 变量在内存中地址： package main import \"fmt\" func main(){ var a int =10 fmt.Printf(\"变量的地址: %x\\n\",&a)} 执行以上代码输出结果为： 变量的地址: c420012058 2. 什么是指针 一个指针变量可以指向任何一个值的内存地址，它指向那个值的内存地址。 类似于变量和常量，在使用指针前你需要声明指针。 指针声明格式如下： var name *类型 指针声明： package main var ip *int /* 指向整型*///声明一个int值得指针变量 var fp *float32 /* 指向浮点型 */ var sp *string /* 指向字符串类型 */ func main(){} 3. 如何使用指针 指针使用流程： 定义指针变量。 为指针变量赋值。 访问指针变量中指向地址的值。 在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。 $ cat pointer.go package main import \"fmt\" func main(){ var a int =20/* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip =&a /* 指针变量的存储地址 */ fmt.Printf(\"a 变量的地址是: %x\\n\",&a)/* 指针变量的存储地址 */ fmt.Printf(\"ip 变量的存储地址: %x\\n\", ip)/* 使用指针访问值 */ fmt.Printf(\"*ip 变量的值: %d\\n\",*ip)} [root@localhost go]# go run pointer.go a 变量的地址是: c000082010 ip 变量的存储地址: c000082010 *ip 变量的值: 20 直接用指针访问目标对象成员： package main import (\"fmt\") func main(){ type data struct{ a int } var d = data{1234} var p *data p =&d fmt.Printf(\"%p, %v\\n\", p, p.a)// 直接用指针访问目标对象成员，无须转换。} 输出结果: 0xc420012058,1234 不能对指针做加减法等运算。 package main func main(){ x :=1234 p :=&x p++} 输出结果： ./main.go:6:3: invalid operation: p++(non-numeric type *int) 可以在 unsafe.Pointer 和任意类型指针间进 转换。 cat pointer2.go package main import ( \"fmt\" \"unsafe\") func main(){ x :=0x12345678 p := unsafe.Pointer(&x)// *int -> Pointer n :=(*[4]byte)(p)// Pointer -> *[4]byte for i :=0; i 将 Pointer 转换成 uintptr，可变相实现指针运算。 $ cat pointer3.go package main import ( \"fmt\" \"unsafe\" ) func main(){ d := struct { s string x int }{\"abc\",100} p :=uintptr(unsafe.Pointer(&d)) // *struct -> Pointer -> uintptr p += unsafe.Offsetof(d.x) // uintptr + offset p2 := unsafe.Pointer(p) // uintptr -> Pointer px :=(*int)(p2) d.x = 200 fmt.Printf(\"%#v\\n\", px) fmt.Printf(\"%#v\\n\", d) } [root@localhost pointer]# go run pointer3.go (*int)(0xc00006af30) struct { s string; x int }{s:\"abc\", x:200} 注意:GC 把 uintptr 当成普通整数对象，它无法阻止 “关联” 对象被回收。 4. Go 空指针（nil） 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr。 $ cat pointer4.go package main import \"fmt\" func main(){ var ptr *int fmt.Printf(\"ptr 的值为 : %x\\n\", ptr)} [root@localhost pointer]# go run pointer4.go ptr 的值为 : 0 空指针判断： $ cat pointer5.go package main import (\"fmt\") func main(){ var ptr1 *int var i int =1 ptr2 :=&i if ptr1 == nil { fmt.Println(\"prt1 是空指针\") } if ptr2 != nil { fmt.Println(\"prt2 不是空指针\") } } [root@localhost pointer]# go run pointer5.go prt1 是空指针 prt2 不是空指针 5. Go 指针数组 定义了长度为 3 的整型数组： package main import \"fmt\" const MAX int =3 func main(){ a :=[MAX]int{10,100,200} var i int for i =0; i 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。 以下声明了整型指针数组： var ptr [MAX]*int; ptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中： $ cat pointer7.go package main import \"fmt\" const MAX int =3 func main(){ a :=[]int{9,99,999} var i int var ptr [MAX]*int for i =0; i 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.5.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_12_cycle_control.html":{"url":"Go-Base/go_12_cycle_control.html","title":"go 流程控制","keywords":"","body":"Go 流程控制1. if2.goto3.for3.1 for 与 range 合用3.2 利用函数作为条件判断4. switch5.select5.1 select基本使用5.2 典型用法Go 流程控制 Go中流程控制分三大类：条件判断，循环控制和无条件跳转。 1. if if也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。 Go里面if条件判断语句中不需要括号，如下代码所示 if x > 10 { fmt.Println(\"x is greater than 10\") } else { fmt.Println(\"x is less than 10\") } Go的if还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示 // 计算获取值x,然后根据x返回的大小，判断是否大于10。 if x := computedValue(); x > 10 { fmt.Println(\"x is greater than 10\") } else { fmt.Println(\"x is less than 10\") } //这个地方如果这样调用就编译出错了，因为x是条件里面的变量 fmt.Println(x) 多个条件的时候如下所示： if integer == 3 { fmt.Println(\"The integer is equal to 3\") } else if integer 2.goto Go有goto语句——请明智地使用它。用goto跳转到必须在当前函数内定义的标签。例如假设这样一个循环： func myFunc() { i := 0 Here: //这行的第一个词，以冒号结束作为标签 println(i) i++ goto Here //跳转到Here去 } 标签名是大小写敏感的。 3.for Go里面最强大的一个控制逻辑就是for，它既可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。它的语法如下： for expression1; expression2; expression3 { //... } expression1、expression2和expression3都是表达式，其中expression1和expression3是变量声明或者函数调用返回值之类的，expression2是用来条件判断，expression1在循环开始之前调用，expression3在每轮循环结束之时调用。 一个例子比上面讲那么多更有用，那么我们看看下面的例子吧： for1.go package main import \"fmt\" func main(){ sum := 0; for index:=0; index 有些时候需要进行多个赋值操作，由于Go里面没有,操作符，那么可以使用平行赋值i, j = i+1, j-1 sum := 1 for ; sum 其中;也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是while的功能。 sum := 1 for sum 无限循环 for { // ... } 这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条break或return语句。 在循环里面有两个关键操作break和continue ,break操作是跳出当前循环，continue是跳过本次循环。当嵌套过深的时候，break可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子： for index := 10; index>0; index-- { if index == 5{ break // 或者continue } fmt.Println(index) } // break打印出来10、9、8、7、6 // continue打印出来10、9、8、7、6、4、3、2、1 break和continue还可以跟着标号，用来跳到多重循环中的外层循环 for配合range可以用于读取slice和map的数据： for k,v:=range map { fmt.Println(\"map's key:\",k) fmt.Println(\"map's val:\",v) } 由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用_来丢弃不需要的返回值 例如 for _, v := range map{ fmt.Println(\"map's val:\", v) } 3.1 for 与 range 合用 for2.go package main import \"fmt\" func main() { var b int = 15 var a int numbers := [6]int{1, 2, 3, 5} /* for 循环 */ for a := 0; a [root@localhost for]# go run for1.go a 的值为: 0 a 的值为: 1 a 的值为: 2 a 的值为: 3 a 的值为: 4 a 的值为: 5 a 的值为: 6 a 的值为: 7 a 的值为: 8 a 的值为: 9 a 的值为: 1 a 的值为: 2 a 的值为: 3 a 的值为: 4 a 的值为: 5 a 的值为: 6 a 的值为: 7 a 的值为: 8 a 的值为: 9 a 的值为: 10 a 的值为: 11 a 的值为: 12 a 的值为: 13 a 的值为: 14 a 的值为: 15 第 0 位 x 的值 = 1 第 1 位 x 的值 = 2 第 2 位 x 的值 = 3 第 3 位 x 的值 = 5 第 4 位 x 的值 = 0 第 5 位 x 的值 = 0 3.2 利用函数作为条件判断 for3.go package main func length(s string) int { println(\"call length.\") return len(s) } func main() { s := \"abcd\" for i, n := 0, length(s); i 输出: call length. 0 97 1 98 2 99 3 100 4. switch 有些时候你需要写很多的if-else来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候switch就能很好的解决这个问题。 它的语法如下： switch sExpr { case expr1: some instructions case expr2: some other instructions case expr3: some other instructions default: other code } sExpr和expr1、expr2、expr3的类型必须一致。Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果switch没有表达式，它会匹配true。 sw1.go cat sw1.go package main import \"fmt\" func main() { i := 10 switch { //第一种表达 case i == 1: fmt.Println(\"i is equal to 1\") case i == 2: fmt.Println(\"i is equal to 2\") case i == 10: fmt.Println(\"i is equal to 10\") default: fmt.Println(\"All I know is that i is an integer\") } switch i { //第二种表达 case 1: fmt.Println(\"i is equal to 1\") case 2, 3, 4: fmt.Println(\"i is equal to 2, 3 or 4\") case 10: fmt.Println(\"i is equal to 10\") default: fmt.Println(\"All I know is that i is an integer\") } switch i := 2; { //第三种表达 case i == 1: fmt.Println(\"i is equal to 1\") case i == 2: fmt.Println(\"i is equal to 2\") case i == 10: fmt.Println(\"i is equal to 10\") default: fmt.Println(\"All I know is that i is an integer\") } } [root@localhost switch]# go run sw1.go i is equal to 10 i is equal to 10 i is equal to 2 在第5行中，我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。 sw2.go integer := 6 switch integer { case 4: fmt.Println(\"The integer was 变量 expr1 可以是任何类型，而expr1 和 exprl2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 实例: sw3.go package main import \"fmt\" func main() { /* 定义局部变量 */ var grade string = \"B\" var marks int = 90 switch marks { case 90: grade = \"A\" case 80: grade = \"B\" case 50,60,70 : grade = \"C\" default: grade = \"D\" } switch { case grade == \"A\" : fmt.Printf(\"优秀!\\n\" ) case grade == \"B\", grade == \"C\" : fmt.Printf(\"良好\\n\" ) case grade == \"D\" : fmt.Printf(\"及格\\n\" ) case grade == \"F\": fmt.Printf(\"不及格\\n\" ) default: fmt.Printf(\"差\\n\" ) } fmt.Printf(\"你的等级是 %s\\n\", grade ) } 以上代码执行结果为： 优秀! 你的等级是 A witch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。 Type Switch 语法格式如下： switch x.(type){ case type: statement(s) case type: statement(s) /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s) } sw4.go package main import \"fmt\" func main() { var x interface{} //写法一： switch i := x.(type) { // 带初始化语句 case nil: fmt.Printf(\" x 的类型 :%T\\r\\n\", i) case int: fmt.Printf(\"x 是 int 型\") case float64: fmt.Printf(\"x 是 float64 型\") case func(int) float64: fmt.Printf(\"x 是 func(int) 型\") case bool, string: fmt.Printf(\"x 是 bool 或 string 型\") default: fmt.Printf(\"未知型\") } //写法二 var j = 0 switch j { case 0: case 1: fmt.Println(\"1\") case 2: fmt.Println(\"2\") default: fmt.Println(\"def\") } //写法三 var k = 0 switch k { case 0: println(\"fallthrough\") fallthrough /* Go的switch非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项； 而如果switch没有表达式，它会匹配true。 Go里面switch默认相当于每个case最后带有break， 匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。 */ case 1: fmt.Println(\"1\") case 2: fmt.Println(\"2\") default: fmt.Println(\"def\") } //写法三 var m = 0 switch m { case 0, 1: fmt.Println(\"1\") case 2: fmt.Println(\"2\") default: fmt.Println(\"def\") } //写法四 var n = 0 switch { //省略条件表达式，可当 if...else if...else case n > 0 && n 0 and i 10 && n 10 and i 以上代码执行结果为： x 的类型 : fallthrough 1 1 def 5.select select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 select 是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。 Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个case都必须是一个通信 所有channel表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行；其他被忽略。 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。 否则： 如果有default子句，则执行该语句。 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。 实例： select1.go package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 以上代码执行结果为： no communication select可以监听channel的数据流动 select的用法与switch语法非常类似，由select开始的一个新的选择块，每个选择条件由case语句来描述 与switch语句可以选择任何使用相等比较的条件相比，select由比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作。 select { //不停的在这里检测 case 在一个select语句中，Go会按顺序从头到尾评估每一个发送和接收的语句。 如果其中的任意一个语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。 如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有两种可能的情况： 如果给出了default语句，那么就会执行default的流程，同时程序的执行会从select语句后的语句中恢复。 如果没有default语句，那么select语句将被阻塞，直到至少有一个case可以进行下去。 Golang select的使用及典型用法 5.1 select基本使用 select是Go中的一个控制结构，类似于switch语句，用于处理异步IO操作。select会监听case语句中channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作。 select中的case语句必须是一个channel操作 select中的default子句总是可运行的。 如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行。 如果没有可运行的case语句，且有default语句，那么就会执行default的动作。 如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行。 例如： select2.go package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 5.2 典型用法 超时判断 //比如在下面的场景中，使用全局resChan来接受response，如果时间超过3S,resChan中还没有数据返回，则第二条case将执行 select3.go var resChan = make(chan int) // do request func test() { select { case data := 退出 //主线程（协程）中如下： select4.go var shouldQuit=make(chan struct{}) fun main(){ { //loop } //...out of the loop select { case //再另外一个协程中，如果运行遇到非法操作或不可处理的错误，就向shouldQuit发送数据通知程序停止运行 close(shouldQuit) 判断channel是否阻塞 //在某些情况下是存在不希望channel缓存满了的需求的，可以用如下方法判断 select5.go ch := make (chan int, 5) //... data：=0 select { case ch 参考： https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.3.md http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch3.md?wd=goto Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_13_array.html":{"url":"Go-Base/go_13_array.html","title":"go array 数组","keywords":"","body":"Go array 数组1. 数组特点2. 数组初始化2.1 一维数组2.2 多维数组2.3 多维数组遍历Go array 数组 @[toc] 1. 数组特点 Golang Array和以往认知的数组有很大不同。 数组：是同一种数据类型的固定长度的序列。 数组定义：var a [len]int，比如：var a [5]int，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。 长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型。 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1 for i := 0; i 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。 支持 “==”、”!=” 操作符，因为内存总是被初始化过的。 指针数组 [n]*T，数组指针 [n]T。 2. 数组初始化 2.1 一维数组 全局： var arr0 [5]int = [5]int{1, 2, 3} var arr1 = [5]int{1, 2, 3, 4, 5} var arr2 = [...]int{1, 2, 3, 4, 5, 6} var str = [5]string{3: \"hello world\", 4: \"tom\"} 局部： a := [3]int{1, 2} // 未初始化元素值为 0。 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。 c := [5]int{2: 100, 4: 200} // 使用引号初始化元素。 d := [...]struct { name string age uint8 }{ {\"user1\", 10}, // 可省略元素类型。 {\"user2\", 20}, // 别忘了最后一行的逗号。 } 代码： package main import ( \"fmt\" ) var arr0 [5]int = [5]int{1, 2, 3} var arr1 = [5]int{1, 2, 3, 4, 5} var arr2 = [...]int{1, 2, 3, 4, 5, 6} var str = [5]string{3: \"hello world\", 4: \"tom\"} func main() { a := [3]int{1, 2} // 未初始化元素值为 0。 b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。 c := [5]int{2: 100, 4: 200} // 使用引号初始化元素。 d := [...]struct { name string age uint8 }{ {\"user1\", 10}, // 可省略元素类型。 {\"user2\", 20}, // 别忘了最后一行的逗号。 } fmt.Println(arr0, arr1, arr2, str) fmt.Println(a, b, c, d) } 输出结果： [1 2 3 0 0] [1 2 3 4 5] [1 2 3 4 5 6] [ hello world tom] [1 2 0] [1 2 3 4] [0 0 100 0 200] [{user1 10} {user2 20}] 2.2 多维数组 全局 var arr0 [5][3]int var arr1 [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}} 局部： a := [2][3]int{{1, 2, 3}, {4, 5, 6}} b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} // 第 2 纬度不能用 \"...\"。 代码： package main import ( \"fmt\" ) var arr0 [5][3]int var arr1 [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}} func main() { a := [2][3]int{{1, 2, 3}, {4, 5, 6}} b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} // 第 2 纬度不能用 \"...\"。 fmt.Println(arr0, arr1) fmt.Println(a, b) } 输出结果： [[0 0 0] [0 0 0] [0 0 0] [0 0 0] [0 0 0]] [[1 2 3] [7 8 9]] [[1 2 3] [4 5 6]] [[1 1] [2 2] [3 3]] 值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。 package main import ( \"fmt\" ) func test(x [2]int) { fmt.Printf(\"x: %p\\n\", &x) x[1] = 1000 } func main() { a := [2]int{} fmt.Printf(\"a: %p\\n\", &a) test(a) fmt.Println(a) } 输出结果: a: 0xc42007c010 x: 0xc42007c030 [0 0] 内置函数 len 和 cap 都返回数组长度 (元素数量)。 package main func main() { a := [2]int{} println(len(a), cap(a)) } 输出结果： 2 2 2.3 多维数组遍历 package main import ( \"fmt\" ) func main() { var f [2][3]int = [...][3]int{{1, 2, 3}, {7, 8, 9}} for k1, v1 := range f { for k2, v2 := range v1 { fmt.Printf(\"(%d,%d)=%d \", k1, k2, v2) } fmt.Println() } } 输出结果： (0,0)=1 (0,1)=2 (0,2)=3 (1,0)=7 (1,1)=8 (1,2)=9 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_14_slice.html":{"url":"Go-Base/go_14_slice.html","title":"go slice 切片引用类型","keywords":"","body":"Go slice 切片引用类型1. 前言2. new和make的区别3 切片特点4. [:6:8] 两个冒号的理解5. 切片初始化6. 读写操作7. 通过make来创建切片8. 直接修改 struct array/slice 成员9. append内置函数操作切片9.1 切片追加9.2 向 slice 尾部添加数据，返回新的 slice 对象9.3 slice中cap重新分配规律10. copy切片拷贝11. slice遍历12. 切片resize（调整大小）13. 字符串和切片（string and slice）14. 修改字符串Go slice 切片引用类型 1. 前言 Golang的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。 内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。 package main func main() { a := []int{0, 0, 0} // 提供初始化表达式。 a[1] = 10 b := make([]int, 3) // make slice b[1] = 10 c := new([]int) c[1] = 10 // ./main.go:11:3: invalid operation: c[1] (type *[]int does not support indexing) } 变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收。 获取指针类型所指向的值，使用：” “ 取值符号 。比如：var p int, 使用p获取p指向的值 指针、slice、map、chan等都是引用类型。 2. new和make的区别 make 用来创建map、slice、channel new 用来创建值类型 new 和 make 均是用于分配内存： new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。 make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。new() 是一个函数，不要忘记它的括号。 3 切片特点 1. 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。 2. 切片的长度可以改变，因此，切片是一个可变的数组。 3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 4. cap可以求出slice最大扩张容量，不能超出数组限制。0 4. [:6:8] 两个冒号的理解 常规slice , data[6:8]，从第6位到第8位（返回6， 7），长度len为2， 最大可扩充长度cap为4（6-9） 另一种写法： data[:6:8] 每个数字前都有个冒号， slice内容为data从0到第6位，长度len为6，最大扩充项cap设置为8 a[x:y:z] 切片内容 [x:y] 切片长度: y-x 切片容量:z-x package main import (\"fmt\") func main(){ slice :=[]int{0,1,2,3,4,5,6,7,8,9} d1 := slice[6:8] fmt.Println(d1,len(d1),cap(d1)) d2 := slice[:6:8] fmt.Println(d2,len(d2),cap(d2))} 输出： [6 7] 2 4 [0 1 2 3 4 5] 6 8 5. 切片初始化 全局： var arr =[...]int{0,1,2,3,4,5,6,7,8,9} var slice0 []int = arr[start:end] var slice1 []int = arr[:end] var slice2 []int = arr[start:] var slice3 []int = arr[:] var slice4 = arr[:len(arr)-1]//去掉切片的最后一个元素 局部： arr2 :=[...]int{9,8,7,6,5,4,3,2,1,0} slice5 := arr[start:end] slice6 := arr[:end] slice7 := arr[start:] slice8 := arr[:] slice9 := arr[:len(arr)-1]//去掉切片的最后一个元素 slice1.go package main import (\"fmt\") var arr =[...]int{0,1,2,3,4,5,6,7,8,9} var slice0 []int = arr[2:8] var slice1 []int = arr[0:6]//可以简写为 var slice []int = arr[:end] var slice2 []int = arr[5:10]//可以简写为 var slice[]int = arr[start:] var slice3 []int = arr[0:len(arr)]//var slice []int = arr[:] var slice4 = arr[:len(arr)-1]//去掉切片的最后一个元素 func main(){ fmt.Printf(\"全局变量：arr %v\\n\", arr) fmt.Printf(\"全局变量：slice0 %v\\n\", slice0) fmt.Printf(\"全局变量：slice1 %v\\n\", slice1) fmt.Printf(\"全局变量：slice2 %v\\n\", slice2) fmt.Printf(\"全局变量：slice3 %v\\n\", slice3) fmt.Printf(\"全局变量：slice4 %v\\n\", slice4) fmt.Printf(\"-----------------------------------\\n\") arr2 :=[...]int{9,8,7,6,5,4,3,2,1,0} slice5 := arr[2:8] slice6 := arr[0:6]//可以简写为 slice := arr[:end] slice7 := arr[5:10]//可以简写为 slice := arr[start:] slice8 := arr[0:len(arr)]//slice := arr[:] slice9 := arr[:len(arr)-1]//去掉切片的最后一个元素 fmt.Printf(\"局部变量： arr2 %v\\n\", arr2) fmt.Printf(\"局部变量： slice5 %v\\n\", slice5) fmt.Printf(\"局部变量： slice6 %v\\n\", slice6) fmt.Printf(\"局部变量： slice7 %v\\n\", slice7) fmt.Printf(\"局部变量： slice8 %v\\n\", slice8) fmt.Printf(\"局部变量： slice9 %v\\n\", slice9)} 输出结果： 全局变量：arr [0123456789] 全局变量：slice0 [234567] 全局变量：slice1 [012345] 全局变量：slice2 [56789] 全局变量：slice3 [0123456789] 全局变量：slice4 [012345678]----------------------------------- 局部变量： arr2 [9876543210] 局部变量： slice5 [234567] 局部变量： slice6 [012345] 局部变量： slice7 [56789] 局部变量： slice8 [0123456789] 局部变量： slice9 [012345678] 6. 读写操作 实际目标是底层数组，只需注意索引号的差别。 package main import (\"fmt\") func main(){ data :=[...]int{0,1,2,3,4,5} s := data[2:4] s[0]+=100 s[1]+=200 fmt.Println(s) fmt.Println(data)} 输出: [102203][0110220345] 7. 通过make来创建切片 语法： func make([]T, len, cap) []T 其中T代表要创建的切片的元素类型。 make函数采用类型，长度和可选容量。 调用时，make会分配一个数组并返回一个引用该数组的切片 var slice []type =make([]type, len) slice :=make([]type, len) slice :=make([]type, len, cap) var s []byte s = make([]byte, 5, 5) // s == []byte{0, 0, 0, 0, 0} 省略capacity参数时，默认为指定的长度。 这是相同代码的更简洁版本： s := make([]byte, 5) 可以使用内置的len和cap函数检查切片的长度和容量。 len(s) == 5 cap(s) == 5 slice2.go package main import (\"fmt\") var slice0 []int =make([]int,10) var slice1 =make([]int,10) var slice2 =make([]int,10,10) func main(){ fmt.Printf(\"make全局slice0 ：%v\\n\", slice0) fmt.Printf(\"make全局slice1 ：%v\\n\", slice1) fmt.Printf(\"make全局slice2 ：%v\\n\", slice2) fmt.Println(\"--------------------------------------\") slice3 :=make([]int,10) slice4 :=make([]int,10) slice5 :=make([]int,10,10) fmt.Printf(\"make局部slice3 ：%v\\n\", slice3) fmt.Printf(\"make局部slice4 ：%v\\n\", slice4) fmt.Printf(\"make局部slice5 ：%v\\n\", slice5)} 输出结果： make全局slice0 ：[0000000000] make全局slice1 ：[0000000000] make全局slice2 ：[0000000000]-------------------------------------- make局部slice3 ：[0000000000] make局部slice4 ：[0000000000] make局部slice5 ：[0000000000] 可直接创建 slice 对象，自动分配底层数组。 package main import \"fmt\" func main(){ s1 :=[]int{0,1,2,3,8:100}// 通过初始化表达式构造，可使用索引号。 fmt.Println(s1,len(s1),cap(s1)) s2 :=make([]int,6,8)// 使用 make 创建，指定 len 和 cap 值。 fmt.Println(s2,len(s2),cap(s2)) s3 :=make([]int,6)// 省略 cap，相当于 cap = len。 fmt.Println(s3,len(s3),cap(s3))} 输出结果: [0 1 2 3 0 0 0 0 100] 9 9 [0 0 0 0 0 0] 6 8 [0 0 0 0 0 0] 6 6 用指针直接访问底层数组，退化成普通数组操作 package main import \"fmt\" func main(){ s :=[]int{0,1,2,3} p := &s[2] // *int, 获取底层数组元素指针。*p +=100 fmt.Println(s,p) } 输出 [root@localhost slice]# go run slice2.go [0 1 2 3] 0xc000014190 [][]T，是指元素类型为 []T 。 package main import (\"fmt\") func main(){ data :=[][]int{[]int{1,2,3},[]int{100,200},[]int{11,22,33,44},} fmt.Println(data)} 输出结果： [[123][100200][11223344]] 8. 直接修改 struct array/slice 成员 package main import (\"fmt\") func main(){ d :=[5]struct { x int }{} s := d[:] d[1].x =10 s[2].x =20 fmt.Println(d) fmt.Printf(\"%p, %p\\n\",&d,&d[0])} 输出结果: [{0}{10}{20}{0}{0}]0xc4200160f0,0xc4200160f0 9. append内置函数操作切片 9.1 切片追加 package main import (\"fmt\") func main(){ var a =[]int{1,2,3} fmt.Printf(\"slice a : %v\\n\", a) var b =[]int{4,5,6} fmt.Printf(\"slice b : %v\\n\", b) c :=append(a, b...) fmt.Printf(\"slice c : %v\\n\", c) d :=append(c,7) fmt.Printf(\"slice d : %v\\n\", d) e :=append(d,8,9,10) fmt.Printf(\"slice e : %v\\n\", e)} 输出结果： slice a :[123] slice b :[456] slice c :[123456] slice d :[1234567] slice e :[12345678910] 9.2 向 slice 尾部添加数据，返回新的 slice 对象 package main import (\"fmt\") func main(){ s1 :=make([]int,0,5) fmt.Printf(\"%p\\n\",&s1) s2 :=append(s1,1) fmt.Printf(\"%p\\n\",&s2) fmt.Println(s1, s2)} 输出结果： 0xc42000a0600xc42000a080[][1] 超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满 package main import (\"fmt\") func main(){ data :=[...]int{0,1,2,3,4,10:0} s := data[:2:3] s =append(s,100,200)// 一次 append 两个值，超出 s.cap 限制。 fmt.Println(s, data)// 重新分配底层数组，与原数组无关。 fmt.Println(&s[0],&data[0])// 比对底层数组起始指针。} 输出结果: [01100200][01234000000]0xc4200160f00xc420070060 从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。 9.3 slice中cap重新分配规律 package main import (\"fmt\") func main(){ s :=make([]int,0,1) c :=cap(s) for i :=0; i c { fmt.Printf(\"cap: %d -> %d\\n\", c, n) c = n } } } 10. copy切片拷贝 package main import (\"fmt\") func main(){ s1 :=[]int{1,2,3,4,5} fmt.Printf(\"slice s1 : %v\\n\", s1) s2 :=make([]int,10) fmt.Printf(\"slice s2 : %v\\n\", s2) copy(s2, s1) fmt.Printf(\"copied slice s1 : %v\\n\", s1) fmt.Printf(\"copied slice s2 : %v\\n\", s2) s3 :=[]int{1,2,3} fmt.Printf(\"slice s3 : %v\\n\", s3) s3 =append(s3, s2...) fmt.Printf(\"appended slice s3 : %v\\n\", s3) s3 =append(s3,4,5,6) fmt.Printf(\"last slice s3 : %v\\n\", s3)} 输出结果： slice s1 :[12345] slice s2 :[0000000000] copied slice s1 :[12345] copied slice s2 :[1234500000] slice s3 :[123] appended slice s3 :[1231234500000] last slice s3 :[1231234500000456] 两个 slice 可指向同一底层数组，允许元素区间重叠。 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准 package main import (\"fmt\") func main(){ data :=[...]int{0,1,2,3,4,5,6,7,8,9} fmt.Println(\"array data : \", data) s1 := data[8:] s2 := data[:5] fmt.Printf(\"slice s1 : %v\\n\", s1) fmt.Printf(\"slice s2 : %v\\n\", s2)copy(s2, s1) fmt.Printf(\"copied slice s1 : %v\\n\", s1) fmt.Printf(\"copied slice s2 : %v\\n\", s2) fmt.Println(\"last array data : \", data)} 输出结果: array data :[0123456789] slice s1 :[89] slice s2 :[01234] copied slice s1 :[89] copied slice s2 :[89234] last array data :[8923456789] 应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。 11. slice遍历 package main import (\"fmt\") func main(){ data :=[...]int{0,1,2,3,4,5,6,7,8,9} slice := data[:] for index, value := range slice { fmt.Printf(\"inde : %v , value : %v\\n\", index, value)}} 输出结果： inde :0, value :0 inde :1, value :1 inde :2, value :2 inde :3, value :3 inde :4, value :4 inde :5, value :5 inde :6, value :6 inde :7, value :7 inde :8, value :8 inde :9, value :9 12. 切片resize（调整大小） package main import (\"fmt\") func main(){ var a =[]int{1,3,4,5} fmt.Printf(\"slice a : %v , len(a) : %v\\n\", a,len(a)) b := a[1:2] fmt.Printf(\"slice b : %v , len(b) : %v\\n\", b,len(b)) c := b[0:3] fmt.Printf(\"slice c : %v , len(c) : %v\\n\", c,len(c))} 输出结果： slice a :[1345],len(a):4 slice b :[3],len(b):1 slice c :[345],len(c):3 13. 字符串和切片（string and slice） string底层就是一个byte的数组，因此，也可以进行切片操作。 package main import (\"fmt\") func main(){ str :=\"hello world\" s1 := str[0:5] fmt.Println(s1) s2 := str[6:] fmt.Println(s2)} 输出结果： hello world 14. 修改字符串 string本身是不可变的，因此要改变string中字符。需要如下操作： 英文字符串： package main import (\"fmt\") func main(){ str :=\"Hello world\" s :=[]byte(str)//中文字符需要用[]rune(str) s[6]='G' s = s[:8] s =append(s,'!') str =string(s) fmt.Println(str)} 输出结果： Hello Go! 含有中文字符串： package main import (\"fmt\") func main(){ str :=\"你好，世界！hello world！\" s :=[]rune(str) s[3]='够' s[4]='浪' s[12]='g' s = s[:14] str =string(s) fmt.Println(str)} 输出结果： 你好，够浪！hello go 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.4.2.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_15_map.html":{"url":"Go-Base/go_15_map.html","title":"go map容器引用","keywords":"","body":"Go map容器引用1. map声明2. map初始化2.1 直接初始化（创建）2.2 通过make初始化（创建）3. map操作4. map遍历5. slice与map操作（slice of map）6. map排序7. map反转8. 容器和结构体（map and struct）Go map容器引用 Golang Map：引用类型，哈希表。一堆键值对的未排序集合。 键必须是支持相等运算符 (“==”、”!=”) 类型， 如 number、string、 pointer、array、struct，以及对应的 interface。值可以是任意类型，没有限制。 1. map声明 声明map的语法如下 var map变量名 map[key] value 其中：key为键类型，value为值类型 例如：value不仅可以是标注数据类型，也可以是自定义数据类型 package main type personInfo struct { ID string Name string Address string } var m1 map[string]int var m2 map[string]personInfo func main(){} 2. map初始化 2.1 直接初始化（创建） package main import (\"fmt\") var m1 map[string]float32 = map[string]float32{\"C\":5,\"Go\":4.5,\"Python\":4.5,\"C++\":2} func main(){ m2 := map[string]float32{\"C\":5,\"Go\":4.5,\"Python\":4.5,\"C++\":2} m3 := map[int]struct { name string age int }{1:{\"user1\",10},// 可省略元素类型。2:{\"user2\",20},} fmt.Printf(\"全局变量 map m1 : %v\\n\", m1) fmt.Printf(\"局部变量 map m2 : %v\\n\", m2) fmt.Printf(\"局部变量 map m3 : %v\\n\", m3)} 输出结果： 全局变量 map m1 : map[Python:4.5 C++:2 C:5 Go:4.5] 局部变量 map m2 : map[C++:2 C:5 Go:4.5 Python:4.5] 局部变量 map m3 : map[2:{user2 20}1:{user1 10}] 注意：由m1,m2可以看出map是键值对的无序集合。 2.2 通过make初始化（创建） Go语言提供的内置函数make()可以用于灵活地创建map。 预先给 make 函数一个合理元素数量参数，有助于提升性能。因为事先申请一大块内存，可避免后续操作时频繁扩张。 package main import (\"fmt\") func main(){// 创建了一个键类型为string,值类型为int的map m1 :=make(map[string]int)// 也可以选择是否在创建时指定该map的初始存储能力，如创建了一个初始存储能力为5的map m2 :=make(map[string]int,5) m1[\"a\"]=1 m2[\"b\"]=2 fmt.Printf(\"局部变量 map m1 : %v\\n\", m1) fmt.Printf(\"局部变量 map m2 : %v\\n\", m2)} 输出结果： 局部变量 map m1 : map[a:1] 局部变量 map m2 : map[b:2] 3. map操作 插入、更新、查找、删除、判断是否存在、求长度 package main import (\"fmt\") func main(){ m := map[string]string{\"key0\":\"value0\",\"key1\":\"value1\"} fmt.Printf(\"map m : %v\\n\", m)//map插入 m[\"key2\"]=\"value2\" fmt.Printf(\"inserted map m : %v\\n\", m)//map修改 m[\"key0\"]=\"hello world!\" fmt.Printf(\"updated map m : %v\\n\", m)//map查找 val, ok := m[\"key0\"]if ok { fmt.Printf(\"map's key0 is %v\\n\", val)}// 长度：获取键值对数量。 len :=len(m) fmt.Printf(\"map's len is %v\\n\", len)// cap 无效，error// cap := cap(m) //invalid argument m (type map[string]string) for cap// fmt.Printf(\"map's cap is %v\\n\", cap)// 判断 key 是否存在。if val, ok = m[\"key\"];!ok { fmt.Println(\"map's key is not existence\")}// 删除，如果 key 不存在，不会出错。if val, ok = m[\"key1\"]; ok {delete(m,\"key1\") fmt.Printf(\"deleted key1 map m : %v\\n\", m)}} 输出结果： map m : map[key0:value0 key1:value1] inserted map m : map[key0:value0 key1:value1 key2:value2] updated map m : map[key0:hello world! key1:value1 key2:value2] map's key0 is hello world! map's len is 3 map's key is not existence deleted key1 map m : map[key0:hello world! key2:value2] 4. map遍历 不能保证迭代返回次序，通常是随机结果，具体和版本实现有关。 package main import (\"fmt\") func main(){ m :=make(map[int]int) for i :=0; i value : %v -> %v\\n\", k, v) } } } 输出结果： map[0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9] map[0:0 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8 9:9] --------------------- key -> value : 2 -> 2 key -> value : 3 -> 3 key -> value : 4 -> 4 key -> value : 7 -> 7 key -> value : 0 -> 0 key -> value : 1 -> 1 key -> value : 5 -> 5 key -> value : 6 -> 6 key -> value : 8 -> 8 key -> value : 9 -> 9 --------------------- key -> value : 4 -> 4 key -> value : 7 -> 7 key -> value : 2 -> 2 key -> value : 3 -> 3 key -> value : 5 -> 5 key -> value : 6 -> 6 key -> value : 8 -> 8 key -> value : 9 -> 9 key -> value : 0 -> 0 key -> value : 1 -> 1 5. slice与map操作（slice of map） package main import (\"fmt\") func main(){ items :=make([]map[int]int,5) for i :=0; i 6. map排序 cat map3.go package main import (\"fmt\";\"sort\") func main(){ m := map[string]string{\"q\":\"q\",\"w\":\"w\",\"e\":\"e\",\"r\":\"r\",\"t\":\"t\",\"y\":\"y\"} var slice []string for k, _ := range m { slice =append(slice, k)} fmt.Printf(\"clise string is : %v\\n\", slice) sort.Strings(slice[:]) fmt.Printf(\"sorted slice string is : %v\\n\", slice) for _, v := range slice { fmt.Println(m[v]) } } [root@localhost map]# go run map3.go clise string is : [w e r t y q] sorted slice string is : [e q r t w y] e q r t w y 7. map反转 cat map4.go package main import (\"fmt\") func main(){ m := map[int]string{1:\"x\",2:\"w\",3:\"e\",4:\"r\",5:\"t\",6:\"y\"} fmt.Println(m) m_rev :=make(map[string]int) for k, v := range m { m_rev[v]= k } fmt.Println(m_rev) } [root@localhost map]# go run map4.go map[1:x 2:w 3:e 4:r 5:t 6:y] map[e:3 r:4 t:5 w:2 x:1 y:6] 8. 容器和结构体（map and struct） cat map5.go package main import \"fmt\" func main(){ type user struct{ name string } m := map[int]user{1:{\"user1\"},} fmt.Println(m) u := m[1] u.name =\"Tom\" m[1]= u fmt.Println(m) m2 := map[int]*user{1:&user{\"user1\"},} m2[1].name =\"Jack\" fmt.Println(m2) } [root@localhost map]# go run map5.go map[1:{user1}] map[1:{Tom}] map[1:0xc000010230] 可以在迭代时安全删除键值。但如果期间有新增操作，那么就不知道会有什么意外了 cat map6.go package main import \"fmt\" func main(){ for i :=0; i 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.4.3.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_16_struc.html":{"url":"Go-Base/go_16_struc.html","title":"go struc 结构体","keywords":"","body":"Go struc 结构体1. struct类型2. struct 特点2.1 特性3. 结构体的声明4. 创建命名的结构体5. 创建匿名结构体6. 结构体的零值（Zero Value）7. 访问结构体的字段8. 结构体的指针9. 匿名字段10. 嵌套结构体（Nested Structs）11. 提升字段（Promoted Fields）12. 导出结构体和字段13. 结构体相等性（Structs Equality）14. struct与tag应用14.1 struct成员变量标签（Tag）说明14.2 struct成员变量标签（Tag）获取15. struct与方法16. struct与函数17. 遍历链表18. 内存对齐影响struct的大小19. 使用注意：19.1 struct的赋值Go struc 结构体 1. struct类型 可将类型分为命名和未命名两大类： 命名类型包括 bool、int、string 等 array、slice、map 等和具体元素类型、长度等有关，属于未命名类型。 具有相同声明的未命名类型被视为同一类型 具有相同基类型的指针。 具有相同元素类型和长度的 array。 具有相同元素类型的 slice。 具有相同键值类型的 map。 具有相同元素类型和传送方向的 channel。 具有相同字段序列 (字段名、类型、标签、顺序) 的匿名 struct。 签名相同 (参数和返回值，不包括参数名称) 的function。 方法集相同 ( 方法名、方法签名相同，和次序无关) 的 interface。 2. struct 特点 用来自定义复杂数据结构 struct里面可以包含多个字段（属性） struct类型可以定义方法，注意和函数的区分 struct类型是值类型 struct类型可以嵌套 Go语言没有class类型，只有struct类型 结构体是用户单独定义的类型，不能和其他类型进行强制转换 golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题。 我们可以为struct中的每个字段，写上一个tag。这个tag可以通过反射的机制获取到，最常用的场景就是json序列化和反序列化。 2.1 特性 值传递 结构体与数组一样，是复合类型，无论是作为实参传递给函数时，还是赋值给其他变量，都是值传递，即复一个副本。 没有继承 Go语言是支持面向对象编程的，但却没有继承的概念，在结构体中，可以通过组合其他结构体来构建更复杂的结构体。 结构体不能包含自己 一个结构体，并没有包含自身，比如Member中的字段不能是Member类型，但却可能是*Member。 引用指针为什么要用new或make？ Go语言中new和make的区别 3. 结构体的声明 type Employee struct { firstName string lastName string age int } 在上面的代码片段里，声明了一个结构体类型 Employee，它有 firstName、lastName 和 age 三个字段。通过把相同类型的字段声明在同一行，结构体可以变得更加紧凑。在上面的结构体中，firstName 和 lastName 属于相同的 string 类型，于是这个结构体可以重写为： type Employee struct { firstName, lastName string age, salary int } 上面的结构体 Employee 称为 命名的结构体（Named Structure）。我们创建了名为 Employee 的新类型，而它可以用于创建 Employee 类型的结构体变量。 声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 匿名结构体（Anonymous Structure）。 var employee struct { firstName, lastName string age int } 4. 创建命名的结构体 方法有几种： package main import ( \"fmt\" ) type Test struct { int string } var a Test func main() { b := new(Test) //同 var b *Test = new(Test) c := Test{1, \"c\"} d := Test{} e := &Test{} f := &Test{2, \"f\"} //同 var d *Test = &Test{2, \"f\"} fmt.Println(a, b, c, d, e, f) // 注: a b c d 返回 Test 类型变量；e f 返回 *Test 类型变量；若无初始化值，则默认为零值 } [root@localhost struct]# ls stru1.go stru2.go stru3.go [root@localhost struct]# go run stru3.go {0 } &{0 } {1 c} {0 } &{0 } &{2 f} 初始化值可以分为两种: a. 有序: typeName{value1, value2, …} 必须一一对应 b. 无序: typeName{field1:value1, field2:value2, …} 可初始化部分值 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { //creating structure using field names emp1 := Employee{ firstName: \"Sam\", age: 25, salary: 500, lastName: \"Anderson\", } //creating structure without using field names emp2 := Employee{\"Thomas\", \"Paul\", 29, 800} fmt.Println(\"Employee 1\", emp1) fmt.Println(\"Employee 2\", emp2) 该程序将输出： Employee 1 {Sam Anderson 25 500} Employee 2 {Thomas Paul 29 800} 5. 创建匿名结构体 package main import ( \"fmt\" ) func main() { emp3 := struct { firstName, lastName string age, salary int }{ firstName: \"Andreah\", lastName: \"Nikola\", age: 31, salary: 5000, } fmt.Println(\"Employee 3\", emp3) } 该程序会输出： Employee 3 {Andreah Nikola 31 5000} 6. 结构体的零值（Zero Value） package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { var emp4 Employee //zero valued structure fmt.Println(\"Employee 4\", emp4) } 该程序定义了 emp4，却没有初始化任何值。因此 firstName 和 lastName 赋值为 string 的零值（\"\"）。而 age 和 salary 赋值为 int 的零值（0）。该程序会输出： Employee 4 { 0 0} 当然还可以为某些字段指定初始值，而忽略其他字段。这样，忽略的字段名会赋值为零值。 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { emp5 := Employee{ firstName: \"John\", lastName: \"Paul\", } fmt.Println(\"Employee 5\", emp5) } 在上面程序中的第 14 行和第 15 行，我们初始化了 firstName 和 lastName，而 age 和 salary 没有进行初始化。因此 age 和 salary 赋值为零值。该程序会输出： Employee 5 {John Paul 0 0} 7. 访问结构体的字段 点号操作符 . 用于访问结构体的字段。 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { emp6 := Employee{\"Sam\", \"Anderson\", 55, 6000} fmt.Println(\"First Name:\", emp6.firstName) fmt.Println(\"Last Name:\", emp6.lastName) fmt.Println(\"Age:\", emp6.age) fmt.Printf(\"Salary: $%d\", emp6.salary) } 在线运行程序[5] 上面程序中的 emp6.firstName 访问了结构体 emp6 的字段 firstName。该程序输出： First Name: Sam Last Name: Anderson Age: 55 Salary: $6000 还可以创建零值的 struct，以后再给各个字段赋值。 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { var emp7 Employee emp7.firstName = \"Jack\" emp7.lastName = \"Adams\" fmt.Println(\"Employee 7:\", emp7) } 在线运行程序[6] 在上面程序中，我们定义了 emp7，接着给 firstName 和 lastName 赋值。该程序会输出： Employee 7: {Jack Adams 0 0} 8. 结构体的指针 还可以创建指向结构体的指针。 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { emp8 := &Employee{\"Sam\", \"Anderson\", 55, 6000} fmt.Println(\"First Name:\", (*emp8).firstName) fmt.Println(\"Age:\", (*emp8).age) } 在线运行程序[7] 在上面程序中，emp8 是一个指向结构体 Employee 的指针。(*emp8).firstName 表示访问结构体 emp8 的 firstName 字段。该程序会输出： First Name: Sam Age: 55 Go 语言允许我们在访问 firstName 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName。 package main import ( \"fmt\" ) type Employee struct { firstName, lastName string age, salary int } func main() { emp8 := &Employee{\"Sam\", \"Anderson\", 55, 6000} fmt.Println(\"First Name:\", emp8.firstName) fmt.Println(\"Age:\", emp8.age) } 在线运行程序[8] 在上面的程序中，我们使用 emp8.firstName 来访问 firstName 字段，该程序会输出： First Name: Sam Age: 55 9. 匿名字段 声明一个 struct1 可以包含已经存在的 struct2 或者go语言中内置类型作为内置字段，称为匿名字段，即只写了 typeName，无 varName，但是 typeName 不能重复。 匿名字段与面向对象程序语言中的继承声明及初始化: type Person struct { string int } 我们接下来使用匿名字段来编写一个程序。 package main import ( \"fmt\" ) type Person struct { string int } func main() { p := Person{\"Naveen\", 50} fmt.Println(p) } 在线运行程序[9] 在上面的程序中，结构体 Person 有两个匿名字段。p := Person{\"Naveen\", 50} 定义了一个 Person 类型的变量。该程序输出 {Naveen 50}。 虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型。比如在上面的 Person 结构体里，虽说字段是匿名的，但 Go 默认这些字段名是它们各自的类型。所以 Person 结构体有两个名为 string 和 int 的字段。 package main import ( \"fmt\" ) type Person struct { string int } func main() { var p1 Person p1.string = \"naveen\" p1.int = 50 fmt.Println(p1) } 在线运行程序[10] 在上面程序的第 14 行和第 15 行，我们访问了 Person 结构体的匿名字段，我们把字段类型作为字段名，分别为 \"string\" 和 \"int\"。上面程序的输出如下： {naveen 50} 10. 嵌套结构体（Nested Structs） 结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。 第一示例 package main import ( \"fmt\" ) type Address struct { city, state string } type Person struct { name string age int address Address } func main() { var p Person p.name = \"Naveen\" p.age = 50 p.address = Address { city: \"Chicago\", state: \"Illinois\", } fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\",p.age) fmt.Println(\"City:\",p.address.city) fmt.Println(\"State:\",p.address.state) } 在线运行程序[11] 上面的结构体 Person 有一个字段 address，而 address 也是结构体。该程序输出： 第二示例 Name: Naveen Age: 50 City: Chicago State: Illinois package main import ( \"fmt\" ) type Person struct { name string age int addr string } type Employee struct { Person //匿名字段 salary int int //用内置类型作为匿名字段 addr string //类似于重载 } func main() { em1 := Employee{Person{\"rain\", 23, \"qingyangqu\"}, 5000, 100, \"gaoxingqu\"} fmt.Println(em1) // var em2 Person = em1 // Error: cannot use em1 (type Employee) as type Person in assignment （没有继承， 然也不会有多态） var em2 Person = em1.Person // 同类型拷贝。 fmt.Println(em2) } [root@localhost struct]# go run stru6.go {{rain 23 qingyangqu} 5000 100 gaoxingqu} {rain 23 qingyangqu} 第三示例 package main import \"fmt\" type Person struct { name string age int addr string } type Employee struct { Person //匿名字段 salary int int //用内置类型作为匿名字段 addr string //类似于重载 } func main() { /* var em1 Employee = Employee{} em1.Person = Person{\"rain\", 23, \"帝都\"} em1.salary = 5000 em1.int = 100 //使用时注意其意义，此处无 em1.addr = \"北京\" */ //em1 := Employee{Person{\"rain\", 23, \"帝都\"}, 5000, 100, \"北京\"} //初始化方式不一样，但是结果一样 em1 := Employee{Person: Person{\"Murphy\", 23, \"帝都\"}, salary: 5000, int: 100, addr: \"北京\"} fmt.Println(em1) fmt.Println(\"live addr(em1.addr) = \", em1.addr) fmt.Println(\"work addr(em1.Person.addr) = \", em1.Person.addr) em1.int = 200 //修改匿名字段的值 } [root@localhost struct]# go run stru7.go \\{{Murphy 23 帝都} 5000 100 北京} live addr(em1.addr) = 北京 work addr(em1.Person.addr) = 帝都 空结构 “节省” 内存， 如用来实现 set 数据结构，或者实现没有 “状态” 只有方法的 “静态类”。 package main func main() { var null struct{} set := make(map[string]struct{}) set[\"a\"] = null } 不能同时嵌入某一类型和其指针类型，因为它们名字相同。 package main type Resource struct { id int } type User struct { *Resource // Resource // Error: duplicate field Resource name string } func main() { u := User{ &Resource{1}, \"Administrator\", } println(u.id) println(u.Resource.id) } [root@localhost struct]# go run stru8.go 1 1 11. 提升字段（Promoted Fields） type Address struct { city, state string } type Person struct { name string age int Address } 上面的代码片段中，Person 结构体有一个匿名字段 Address，而 Address 是一个结构体。现在结构体 Address 有 city 和 state 两个字段，访问这两个字段就像在 Person 里直接声明的一样，因此我们称之为提升字段。 package main import ( \"fmt\" ) type Address struct { city, state string } type Person struct { name string age int Address } func main() { var p Person p.name = \"Naveen\" p.age = 50 p.Address = Address{ city: \"Chicago\", state: \"Illinois\", } fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\", p.age) fmt.Println(\"City:\", p.city) //city is promoted field fmt.Println(\"State:\", p.state) //state is promoted field } 上面代码中的第 26 行和第 27 行，我们使用了语法 p.city 和 p.state，访问提升字段 city 和 state 就像它们是在结构体 p 中声明的一样。该程序会输出： Name: Naveen Age: 50 City: Chicago State: Illinois 12. 导出结构体和字段 如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。 让我们使用自定义包，编写一个程序来更好地去理解它。 在你的 Go 工作区的 src 目录中，创建一个名为 structs 的文件夹。另外在 structs 中再创建一个目录 computer。 在 computer 目录中，在名为 spec.go 的文件中保存下面的程序。 package computer type Spec struct { //exported struct Maker string //exported field model string //unexported field Price int //exported field } 上面的代码片段中，创建了一个 computer 包，里面有一个导出结构体类型 Spec。Spec 有两个导出字段 Maker 和 Price，和一个未导出的字段 model。接下来我们会在 main 包中导入这个包，并使用 Spec 结构体。 package main import \"structs/computer\" import \"fmt\" func main() { var spec computer.Spec spec.Maker = \"apple\" spec.Price = 50000 fmt.Println(\"Spec:\", spec) } 包结构如下所示： src structs computer spec.go main.go 在上述程序的第 3 行，我们导入了 computer 包。在第 8 行和第 9 行，我们访问了结构体 Spec 的两个导出字段 Maker 和 Price。执行命令 go install structs 和 workspacepath/bin/structs，运行该程序。 如果我们试图访问未导出的字段 model，编译器会报错。将 main.go 的内容替换为下面的代码。 package main import \"structs/computer\" import \"fmt\" func main() { var spec computer.Spec spec.Maker = \"apple\" spec.Price = 50000 spec.model = \"Mac Mini\" fmt.Println(\"Spec:\", spec) } 在上面程序的第 10 行，我们试图访问未导出的字段 model。如果运行这个程序，编译器会产生错误：spec.model undefined (cannot refer to unexported field or method model)。 13. 结构体相等性（Structs Equality） 结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的。 package main import ( \"fmt\" ) type name struct { firstName string lastName string } func main() { name1 := name{\"Steve\", \"Jobs\"} name2 := name{\"Steve\", \"Jobs\"} if name1 == name2 { fmt.Println(\"name1 and name2 are equal\") } else { fmt.Println(\"name1 and name2 are not equal\") } name3 := name{firstName:\"Steve\", lastName:\"Jobs\"} name4 := name{} name4.firstName = \"Steve\" if name3 == name4 { fmt.Println(\"name3 and name4 are equal\") } else { fmt.Println(\"name3 and name4 are not equal\") } } 在线运行程序[13] 在上面的代码中，结构体类型 name 包含两个 string 类型。由于字符串是可比较的，因此可以比较两个 name 类型的结构体变量。 上面代码中 name1 和 name2 相等，而 name3 和 name4 不相等。该程序会输出： name1 and name2 are equal name3 and name4 are not equal 如果结构体包含不可比较的字段，则结构体变量也不可比较。 package main import ( \"fmt\" ) type image struct { data map[int]int } func main() { image1 := image{data: map[int]int{ 0: 155, }} image2 := image{data: map[int]int{ 0: 155, }} if image1 == image2 { fmt.Println(\"image1 and image2 are equal\") } } 在线运行程序[14] 在上面代码中，结构体类型 image 包含一个 map 类型的字段。由于 map 类型是不可比较的，因此 image1 和 image2 也不可比较。如果运行该程序，编译器会报错：main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared) 14. struct与tag应用 在处理json格式字符串的时候，经常会看到声明struct结构的时候，属性的右侧还有小米点括起来的内容。形如： type User struct { UserId int `json:\"user_id\" bson:\"user_id\"` UserName string `json:\"user_name\" bson:\"user_name\"` } 这个小米点里的内容是用来干什么的呢？ 14.1 struct成员变量标签（Tag）说明 要比较详细的了解这个，要先了解一下golang的基础，在golang中，命名都是推荐都是用驼峰方式，并且在首字母大小写有特殊的语法含义：包外无法引用。但是由经常需要和其它的系统进行数据交互，例如转成json格式，存储到mongodb啊等等。这个时候如果用属性名来作为键值可能不一定会符合项目要求。 所以呢就多了小米点的内容，在golang中叫标签（Tag），在转换成其它数据格式的时候，会使用其中特定的字段作为键值。例如上例在转成json格式： package main import ( \"encoding/json\" \"fmt\" ) type User struct { UserId int UserName string } type UserTag struct { UserId int `json:\"user_id\" bson:\"user_id\"` UserName string `json:\"user_name\" bson:\"user_name\"` } func main() { u := &User{UserId: 1, UserName: \"Murphy\"} j, _ := json.Marshal(u) fmt.Printf(\"struct User echo : %v\\n\", string(j)) u_tag := &UserTag{UserId: 1, UserName: \"Murphy\"} j_tag, _ := json.Marshal(u_tag) fmt.Printf(\"struct UserTag echo : %v\\n\", string(j_tag)) } [root@localhost struct]# go run stru9.go struct User echo : {\"UserId\":1,\"UserName\":\"Murphy\"} struct UserTag echo : {\"user_id\":1,\"user_name\":\"Murphy\"} 可以看到直接用struct的属性名做键值。 其中还有一个bson的声明，这个是用在将数据存储到mongodb使用的。 标签是类型的组成部分。 14.2 struct成员变量标签（Tag）获取 那么当我们需要自己封装一些操作，需要用到Tag中的内容时，咋样去获取呢？这边可以使用反射包（reflect）中的方法来获取： t := reflect.TypeOf(u) field := t.Elem().Field(0) fmt.Println(field.Tag.Get(\"json\")) fmt.Println(field.Tag.Get(\"bson\")) 实例 package main import ( \"encoding/json\" \"fmt\" \"reflect\" ) func main() { type User struct { //多个Key使用空格进行分开，然后使用Get方法获取不同Key的值。 UserId int `json:\"user_json_id\" xml:\"user_xml_id\"` UserName string `json:\"user_json_name\" xml:\"user_xml_name\"` } // 输出json格式 u := &User{UserId: 1, UserName: \"tony\"} j, _ := json.Marshal(u) fmt.Println(string(j)) // 获取tag中的内容 t := reflect.TypeOf(u) fmt.Println(t) field0 := t.Elem().Field(0) fmt.Println(field0.Tag.Get(\"json\")) fmt.Println(field0.Tag.Get(\"xml\")) field1 := t.Elem().Field(1) fmt.Println(field1.Tag.Get(\"json\")) fmt.Println(field1.Tag.Get(\"xml\")) } [root@localhost struct]# go run stru10.go {\"user_json_id\":1,\"user_json_name\":\"tony\"} *main.User user_json_id user_xml_id user_json_name user_xml_name 15. struct与方法 实例1定义其初始化方法 package main import \"fmt\" type Member struct { Name string } func (m Member)setName(name string){//绑定到Member结构体的方法 m.Name = name } func main() { m := Member{} m.setName(\"小明\") fmt.Println(m.Name)//输出为空 } [root@localhost struct]# go run stru13.go package main import \"fmt\" type Member struct { Name string } func (m *Member)setName(name string){//绑定到Member结构体的方法 m.Name = name } func main() { m := Member{} m.setName(\"小明\") fmt.Println(m.Name)//输出为空 } [root@localhost struct]# go run stru13.go 小明 上面的代码中，我们会很奇怪，不是调用setName()方法设置了字段Name的值了吗？为什么还是输出为空呢？ 这是因为，结构体是值传递，当我们调用setName时，方法接收器接收到是只是结构体变量的一个副本，通过副本对值进行修复，并不会影响调用者，因此，我们可以将方法接收器定义为指针变量，就可达到修改结构体的目的了。 实例2自定义方法初始化 package main import \"fmt\" type Person struct { Name string Age int } func (self *Person) init(name string ,age int){ self.Name = name self.Age = age } func main() { var person1 = new(Person) person1.init(\"wd\",22) //(&person1).init(\"wd\",22) fmt.Println(person1)//&{wd 22} } 实例3 方法返回 package main import \"fmt\" type Person struct { Name string Age int } func (p Person) Getname() string{ //p代表结构体本身的实列，类似python中的self,这里p可以写为self fmt.Println(p.Name) return p.Name } func main() { var person1 = new(Person) person1.Age = 22 person1.Name = \"wd\" person1.Getname()// wd } 实例4实现结构体中的方法 如果实现了结构体中的String方法，在使用fmt打印时候会调用该方法，类似与python中的str方法. package main import \"fmt\" type Person struct { Name string Age int } func (self *Person) String() string{ return self.Name } func main() { var person1 = new(Person) person1.Name = \"wd\" person1.Age = 22 fmt.Println(person1)// wd } 16. struct与函数 自定义构造函数 package main import \"fmt\" type Student struct { name string age int Class string } func Newstu(name1 string,age1 int,class1 string) *Student { return &Student{name:name1,age:age1,Class:class1} } func main() { stu1 := Newstu(\"wd\",22,\"math\") fmt.Println(stu1.name) // wd } 17. 遍历链表 链表的遍历是通过移动指针进行遍历，当指针到最好一个节点时，其next指针为nil package main import \"fmt\" type Node struct { data int next *Node } func Shownode(p *Node){ //遍历 for p != nil{ fmt.Println(*p) p=p.next //移动指针 } } func main() { var head = new(Node) head.data = 1 var node1 = new(Node) node1.data = 2 head.next = node1 var node2 = new(Node) node2.data = 3 node1.next = node2 Shownode(head) } //{1 0xc42000e1e0} //{2 0xc42000e1f0} //{3 } 18. 内存对齐影响struct的大小 我们定义一个struct，这个struct有3个字段，它们的类型有byte,int32以及int64,但是这三个字段的顺序我们可以任意排列，那么根据顺序的不同，一共有6种组合。 type user1 struct { b byte i int32 j int64 } type user2 struct { b byte j int64 i int32 } type user3 struct { i int32 b byte j int64 } type user4 struct { i int32 j int64 b byte } type user5 struct { j int64 b byte i int32 } type user6 struct { j int64 i int32 b byte } 根据这6种组合，定义了6个struct，分别位user1，user2，…，user6，那么现在大家猜测一下，这6种类型的struct占用的内存是多少，就是unsafe.Sizeof()的值。 大家可能猜测1+4+8=13，因为byte的大小为1，int32大小为4，int64大小为8，而struct其实就是一个字段的组合，所以猜测struct大小为字段大小之和也很正常。 但是，但是，我可以明确的说，这是错误的。 为什么是错误的，因为有内存对齐存在，编译器使用了内存对齐，那么最后的大小结果就不一样了。现在我们正式验证下，这几种struct的值。 package main import ( \"fmt\" \"unsafe\" ) type user1 struct { b byte i int32 j int64 } type user2 struct { b byte j int64 i int32 } type user3 struct { i int32 b byte j int64 } type user4 struct { i int32 j int64 b byte } type user5 struct { j int64 b byte i int32 } type user6 struct { j int64 i int32 b byte } func main() { var u1 user1 var u2 user2 var u3 user3 var u4 user4 var u5 user5 var u6 user6 fmt.Println(\"u1 size is \", unsafe.Sizeof(u1)) fmt.Println(\"u2 size is \", unsafe.Sizeof(u2)) fmt.Println(\"u3 size is \", unsafe.Sizeof(u3)) fmt.Println(\"u4 size is \", unsafe.Sizeof(u4)) fmt.Println(\"u5 size is \", unsafe.Sizeof(u5)) fmt.Println(\"u6 size is \", unsafe.Sizeof(u6)) } [root@localhost struct]# go run stru11.go u1 size is 16 u2 size is 24 u3 size is 16 u4 size is 24 u5 size is 16 u6 size is 16 内存对齐影响struct的大小 struct的字段顺序影响struct的大小 综合以上两点，我们可以得知，不同的字段顺序，最终决定struct的内存大小，所以有时候合理的字段顺序可以减少内存的开销。 19. 使用注意： 19.1 struct的赋值 错误实例 package main import( \"fmt\" ) type person struct { name string age int } var P person P.name = \"annie\" P.age = 20 func main() { fmt.Printf(\"The person's name is %s\", P.name) } [root@localhost struct]# go run stru12.go # command-line-arguments ./stru12.go:14:1: syntax error: non-declaration statement outside function body 正确写法1 package main import( \"fmt\" ) type person struct { name string age int } var P =person{\"annie\",20} func main() { fmt.Printf(\"The person's name is %s\", P.name) } 正确写法2 package main import( \"fmt\" ) type person struct { name string age int } var P person func main() { P.name=\"a\" P.age=10 fmt.Printf(\"The person's name is %s\", P.name) } go和c一样，所有的运算都应该在函数内进行，函数外进行的是语法错误。 函数体外初始化结构体就两个办法，要么一次性全部赋值，要么先声明（全局/局部）变量，在某个函数内进行赋值，在函数体外进行结构体成员赋值相当于函数外面进行运算了。 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch3.md?wd=goto https://segmentfault.com/q/1010000009276425 https://www.cnblogs.com/wdliu/p/9209419.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_17_function.html":{"url":"Go-Base/go_17_function.html","title":"go 了解函数运用","keywords":"","body":"Go 了解函数运用1. 函数特点2. 函数参数2.1 参数传递2.2 不定参数传值3. 函数返回值4. 匿名函数5. 函数闭包6. 递归函数Go 了解函数运用 1. 函数特点 • 无需声明原型。 • 支持不定 变参。 • 支持多返回值。 • 支持命名返回参数。 • 支持匿名函数和闭包。 • 函数也是一种类型，一个函数可以赋值给变量。 • 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。 • 不支持 重载 (overload) • 不支持 默认参数 (default parameter)。 2. 函数参数 2.1 参数传递 函数定义时指出，函数定义时有参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。 但当调用函数，传递过来的变量就是函数的实参，函数可以通过两种方式来传递参数： 值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 func swap(x, y int) int {......} 引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 arg1.go package main import (\"fmt\")/* 定义相互交换值的函数 */ func swap(x, y *int){ var temp int temp = *x /* 保存 x 的值 */ *x = *y /* 将 y 值赋给 x */ *y = temp /* 将 temp 值赋给 y*/ } func main(){ var a, b int =1,2 /* 调用 swap() 函数 &a 指向 a 指针，a 变量的地址 &b 指向 b 指针，b 变量的地址 */ swap(&a,&b) fmt.Println(a, b) } 输出结果： 21 在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。 注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。 注意2：map、slice、chan、指针、interface默认以引用的方式传递。 2.2 不定参数传值 就是函数的参数不是固定的，后面的类型是固定的。（可变参数） Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。 在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。 func myfunc(args ...int){//0个或多个参数} func add(a int, args…int) int {//1个或多个参数} func add(a int, b int, args…int) int {//2个或多个参数} 注意：其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数. 任意类型的不定参数： 就是函数的参数和每个参数的类型都不是固定的。 用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。 func myfunc(args ...interface{}){} 代码： arg2.go package main import (\"fmt\") func test(s string, n ...int) string { var x int for _, i := range n { x += i } return fmt.Sprintf(s, x) } func main(){ println(test(\"sum: %d\",1,2,3)) } 输出结果： sum:6 使用 slice 对象做变参时，必须展开。（slice...） arg3.go package main import (\"fmt\") func test(s string, n ...int) string { var x int for _, i := range n { x += i } return fmt.Sprintf(s, x) } func main(){ s :=[]int{1,2,3} res :=test(\"sum: %d\", s...)// slice... 展开slice println(res) } 3. 函数返回值 命名返回值 \"_\"标识符，用来忽略函数的某个返回值 Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。 返回值的名称应当具有一定的意义，可以作为文档使用。 没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。 直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。 return1.go package main import (\"fmt\") func add(a, b int)(c int){ c = a + b return } func calc(a, b int)(sum int, avg int){ sum = a + b avg =(a + b)/2 return } func main(){ var a, b int =1,2 c :=add(a, b) sum, avg :=calc(a, b) fmt.Println(a, b, c, sum, avg) } 输出结果： 12331 Golang返回值不能用容器对象接收多返回值。只能用多个变量，或 “_” 忽略。 return2.go package main func test()(int, int){ return1,2 } func main(){ // s := make([]int, 2) // s = test() // Error: multiple-value test() in single-value context x, _ :=test()println(x) } 输出结果： 1 多返回值可直接作为其他函数调用实参。 return3.go package main func test()(int, int){ return1,2 } func add(x, y int) int { return x + y } func sum(n ...int) int { var x int for _, i := range n { x += i } return x } func main(){ println(add(test())) println(sum(test())) } 输出结果： 3 3 命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。 return4.go package main func add(x, y int)(z int){ z = x + y return} func main(){ println(add(1,2)) } 输出结果： 3 命名返回参数可被同名局部变量遮蔽，此时需要显式返回。 return5.go func add(x, y int)(z int){ {// 不能在一个级别，引发 \"z redeclared in this block\" 错误。 var z = x + y // return // Error: z is shadowed during returnreturn z // 必须显式返回。 } } 命名返回参数允许 defer 延迟调用通过闭包读取和修改。 return6.go package main func add(x, y int)(z int){ defer func(){ z +=100}() z = x + y return } func main(){ println(add(1,2)) } 输出结果： 103 显式 return 返回前，会先修改命名返回参数。 return6.go package main func add(x, y int)(z int){ defer func(){println(z)// 输出: 203}() z = x + y return z +200// 执行顺序: (z = z + 200) -> (call defer) -> (return) } func main(){ println(add(1,2))// 输出: 203 } 输出结果： 203 203 4. 匿名函数 匿名函数是指不需要定义函数名的一种函数实现方式。1958年LISP首先采用匿名函数。 在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。 匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。 anon1.go package main import (\"fmt\"\"math\") func main(){ getSqrt :=func(a float64) float64 { return math.Sqrt(a) } fmt.Println(getSqrt(4)) } 输出结果： 2 上面先定义了一个名为getSqrt 的变量，初始化该变量时和之前的变量初始化有些不同，使用了func，func是定义函数的，可是这个函数和上面说的函数最大不同就是没有函数名，也就是匿名函数。这里将一个函数当做一个变量一样的操作。 Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。 anon2.go package main func main() { // --- function variable --- fn := func() { println(\"Hello, World!\") } fn() // --- function collection --- fns := [](func(x int) int){ func(x int) int { return x + 1 }, func(x int) int { return x + 2 }, } println(fns[0](100)) // --- function as field --- d := struct { fn func() string }{ fn: func() string { return \"Hello, World!\" }, } println(d.fn()) // --- channel of function --- fc := make(chan func() string, 2) fc 输出结果： Hello, World!101 Hello, World! Hello, World! 5. 函数闭包 闭包的应该都听过，但到底什么是闭包呢？ 闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。 “官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 维基百科讲，闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 看着上面的描述，会发现闭包和匿名函数似乎有些像。可是可能还是有些云里雾里的。因为跳过闭包的创建过程直接理解闭包的定义是非常困难的。目前在JavaScript、Go、PHP、Scala、Scheme、Common Lisp、Smalltalk、Groovy、Ruby、 Python、Lua、objective c、Swift 以及Java8以上等语言中都能找到对闭包不同程度的支持。通过支持闭包的语法可以发现一个特点，他们都有垃圾回收(GC)机制。 javascript应该是普及度比较高的编程语言了，通过这个来举例应该好理解写。看下面的代码，只要关注script里方法的定义和调用就可以了。 function a(){ var i=0; function b(){ console.log(++i); document.write(\"\"+i+\"\"); } return b; } $(function(){ var c=a(); c(); c(); c(); //a(); //不会有信息输出 document.write(\"=============\"); var c2=a(); c2(); c2(); }); 这段代码有两个特点： 函数b嵌套在函数a内部 函数a返回函数b 这样在执行完var c=a()后，变量c实际上是指向了函数b()，再执行函数c()后就会显示i的值，第一次为1，第二次为2，第三次为3，以此类推。 其实，这段代码就创建了一个闭包。因为函数a()外的变量c引用了函数a()内的函数b()，就是说： 当函数a()的内部函数b()被函数a()外的一个变量引用的时候，就创建了一个闭包。 在上面的例子中，由于闭包的存在使得函数a()返回后，a中的i始终存在，这样每次执行c()，i都是自加1后的值。 从上面可以看出闭包的作用就是在a()执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a()所占用的资源，因为a()的内部函数b()的执行需要依赖a()中的变量i。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。变量的作用域仅限于包含它们的函数，因此无法从其它程序代码部分进行访问。不过，变量的生存期是可以很长，在一次函数调用期间所创建所生成的值在下次函数调用时仍然存在。正因为这一特点，闭包可以用来完成信息隐藏，并进而应用于需要状态表达的某些编程范型中。 下面来想象另一种情况，如果a()返回的不是函数b()，情况就完全不同了。因为a()执行完后，b()没有被返回给a()的外界，只是被a()所引用，而此时a()也只会被b()引 用，因此函数a()和b()互相引用但又不被外界打扰（被外界引用），函数a和b就会被GC回收。所以直接调用a();是页面并没有信息输出。 下面来说闭包的另一要素引用环境。c()跟c2()引用的是不同的环境，在调用i++时修改的不是同一个i，因此两次的输出都是1。函数a()每进入一次，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。这和c()和c()的调用顺序都是无关的。 Go的闭包 Go语言是支持闭包的，这里只是简单地讲一下在Go语言中闭包是如何实现的。 下面我来将之前的JavaScript的闭包例子用Go来实现。 bibao1.go package main import ( \"fmt\" ) func a() func() int { i := 0 b := func() int { i++ fmt.Println(i) return i } return b } func main() { c := a() c() c() c() a() //不会输出i } 输出结果： 1 2 3 可以发现，输出和之前的JavaScript的代码是一致的。具体的原因和上面的也是一样的，这说明Go语言是支持闭包的。 闭包复制的是原对象指针，这就很容易解释延迟引用现象。 bibao2.go package main import \"fmt\" func test() func() { x := 100 fmt.Printf(\"x (%p) = %d\\n\", &x, x) return func() { fmt.Printf(\"x (%p) = %d\\n\", &x, x) } } func main() { f := test() f() } 输出: x (0xc42007c008)=100 x (0xc42007c008)=100 在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。 FuncVal { func_address, closure_var_pointer ...} 6. 递归函数 递归，就是在运行的过程中调用自己。 一个函数调用自己，就叫做递归函数。 构成递归需具备的条件： 子问题须与原始问题为同样的事，且更为简单。 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 数字阶乘 一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。 package main import \"fmt\" func factorial(i int) int { if i 输出结果： Factorial of 7 is 5040 斐波那契数列(Fibonacci) 这个数列从第3项开始，每一项都等于前两项之和。 package main import \"fmt\" func fibonaci(i int) int { if i == 0 { return 0 } if i == 1 { return 1 } return fibonaci(i-1) + fibonaci(i-2) } func main() { var i int for i = 0; i 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch4.5.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_18_init_function.html":{"url":"Go-Base/go_18_init_function.html","title":"go init 函数","keywords":"","body":"Go init 函数1. 介绍2. 作用3. 特点4. 测试Go init 函数 1. 介绍 golang中有个神奇的函数init,该函数会在所有程序执行开始前被调用，每个包可以包含多个init函数，所有被编辑器识别到的init函数都会在main函数执行前被调用。通常被用来注册一个程序需要使用的依赖，如mysql注册，配置文件加载等。 2. 作用 初始化不能采用初始化表达式初始化的变量。 程序运行前的注册。 实现sync.Once功能。 其他 3. 特点 init函数先于main函数自动执行，不能被其他函数调用； init函数没有输入参数、返回值； 每个包可以有多个init函数； 包的每个源文件也可以有多个init函数，这点比较特殊； 同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。 不同包的init函数按照包导入的依赖关系决定执行顺序。 4. 测试 golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下： 初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似，参见golang变量的初始化）； 初始化包作用域的变量（该作用域的变量的初始化也并非按照“从上到下、从左到右”的顺序，runtime解析变量依赖关系，没有依赖的变量最先初始化，参见golang变量的初始化）； 执行包的init函数； package main import ( \"fmt\" ) var T int64 = a() func init() { fmt.Println(\"init in main.go \") } func a() int64 { fmt.Println(\"calling a()\") return 2 } func main() { fmt.Println(\"calling main\") } [root@localhost init]# go run init2.go calling a() init in main.go calling main 初始化顺序：变量初始化->init()->main() 示例2： pack.go package pack import ( \"fmt\" \"test_util\" ) var Pack int = 6 func init() { a := test_util.Util fmt.Println(\"init pack \", a) } test_util.go test_util.go package test_util import \"fmt\" var Util int = 5 func init() { fmt.Println(\"init test_util\") } main.go package main import ( \"fmt\" \"pack\" \"test_util\" ) func main() { fmt.Println(pack.Pack) fmt.Println(test_util.Util) } 输出： init test_util init pack 5 6 5 由于pack包的初始化依赖test_util，因此运行时先初始化test_util再初始化pack包； 示例3： sandbox.go package main import \"fmt\" var _ int64 = s() func init() { fmt.Println(\"init in sandbox.go\") } func s() int64 { fmt.Println(\"calling s() in sandbox.go\") return 1 } func main() { fmt.Println(\"main\") } a.go package main import \"fmt\" var _ int64 = a() func init() { fmt.Println(\"init in a.go\") } func a() int64 { fmt.Println(\"calling a() in a.go\") return 2 } z.go package main import \"fmt\" var _ int64 = z() func init() { fmt.Println(\"init in z.go\") } func z() int64 { fmt.Println(\"calling z() in z.go\") return 3 } [root@localhost test2]# go run sandbox.go a.go z.go calling s() in sandbox.go calling a() in a.go calling z() in z.go init in sandbox.go init in a.go init in z.go main 同一个包不同源文件的init函数执行顺序，golang spec没做说明，以上述程序输出来看，执行顺序是源文件名称的字典序。 示例4： package main import \"fmt\" func init() { fmt.Println(\"init\") } func main() { init() } init函数不可以被调用，上面代码会提示：undefined: init 示例5： package main import \"fmt\" func init() { fmt.Println(\"init 1\") } func init() { fmt.Println(\"init 2\") } func main() { fmt.Println(\"main\") } 输出： init 1 init 2 main init函数比较特殊，可以在包里被多次定义。 示例6： var initArg [20]int func init() { initArg[0] = 10 for i := 1; i init函数的主要用途：初始化不能使用初始化表达式初始化的变量 示例7： import _ \"net/http/pprof\" golang对没有使用的导入包会编译报错，但是有时我们只想调用该包的init函数，不使用包导出的变量或者方法，这时就采用上面的导入方案。 执行上述导入后，init函数会启动一个异步协程采集该进程实例的资源占用情况，并以http服务接口方式提供给用户查询。 参考： https://zhuanlan.zhihu.com/p/34211611 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_19_built_in_function.html":{"url":"Go-Base/go_19_built_in_function.html","title":"go 内置函数","keywords":"","body":"Go 内置函数1. close2. len 和 cap3. new 与 make4. append5. copy6. delete7. panic 与 recoverGo 内置函数 1. close close用于关闭一个channel，使用close函数要注意以下几点： 关闭一个只接受的channel会导致错误 在一个已经关闭的channel上发送数据会导致panic 关闭一个nil channel会导致panic 在一个channel关闭之后，如果channel已经没有剩余数据等待接受了，这时候如果继续接收，会返回一个channel对应数据类型的nil value，如果接收的时候使用多返回值，第二个参数表示一个channel是否已经关闭。 package main import \"fmt\" func main() { ch := make(chan int, 5) for i := 0; i 在close之后， 还可以读取， 不过在读取完之后， 再检测ok, 就是false了 2. len 和 cap len和cap都接收多种类型的参数，返回值是int类型，具体接收哪些类型的参数 创建方式make([]type, len, cap)，其中，type表示数组元素类型，len表示长度，cap表示容量 以及返回的值的含义见下表 len(s) string 字符串的字节长度 [n]T *[n]T 数组的长度（==n） []T slice的长度 map[K][T] map的长度，即有多少个key-value对 chan T 在channel里面有多少个等待接收的元素 cap(s) [n]T *[n]T 数组长度（==n） []T slice的capacity（预分配空间） chan T channel的buffer的长度 len，cap的返回值满足如下条件： 0 3. new 与 make $ cat mem.go package main import ( \"fmt\" ) func main() { var i *int *i=10 fmt.Println(*i) } [root@localhost func]# go run mem.go panic: runtime error: invalid memory address or nil pointer dereference 从这个提示中可以看出，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间，否则我们的值放在哪里去呢？这就是上面错误提示的原因 对于值类型的声明不需要，是因为已经默认帮我们分配好了 分配内存，Go提供了两种方式，分别是new和make 3.1 new new函数的参数是一个类型，返回一个指向该类型的指针，并且进行0值初始化 func new(Type) *Type 它只接受一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针。同时请注意它同时把分配的内存置为零，也就是类型的零值。那么上面的函数可以改写成 $ cat new.go package main import \"fmt\" func main() { var i *int i=new(int) *i=10 fmt.Println(*i) } [root@localhost func]# go run new.go 10 类似new（）的功能： func newInt() *int { var i int return &i } someInt := newInt() m>=n，且n和m必须是整型且不能为负数。 3.2 make make也根据不同参数类型和参数个数具有不同的含义，它的定义比 new 多了一个参数，返回值也不同： func make(Type, size ...IntegerType) Type 内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象(注意：只能用在这三种类型上)，跟 new 类似，第一个参数也是一个类型而不是一个值，跟 new 不同的是，make 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型。 Slice: 第二个参数 size 指定了它的长度，它的容量和长度相同。 你可以传入第三个参数来指定不同的容量值，但必须不能比长度值小。 比如 make([]int, 0, 10) Map: 根据 size 大小来初始化分配内存，不过分配后的 map 长度为 0，如果 size被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存 Channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 0 或者忽略容量，管道是没有缓冲区的 make(T, n) slice 创建一个T类型的slice且长度为n make(T, n, m) slice 创建一个T类型的slice且长度为n，capacity位m make(T) map 创建一个T类型的map make(T, n) map 创建一个T类型的map，且预分配n个空间 make(T) channel 创一个channel make(T, n) channel 创建一个拥有n长度的buffer的channel c := make(chan int) 如果不指定容量，默认通道的容量是0，这种通道也成为非缓冲通道 c := make(chan string, 10) slice数组切片实例： $ cat make1.go package main import \"fmt\" func main() { a := make([]int, 2) b := make([]int, 2, 10) fmt.Println(a, b) fmt.Println(len(a), len(b)) } [root@localhost func]# go run make1.go [0 0] [0 0] 2 2 map字典初始化实例1： package main import ( \"fmt\" \"reflect\" ) func main() { var yinzhengjie map[string]string //先声明一个字典（map）名字叫做yinzhengjie。其key所对应的数据类型是“string”[字符串]，value所对应的数据类型也是“string”。 fmt.Printf(\"判断yinzhengjie字典是否为空:【%v】\\n\",yinzhengjie == nil) //声明的字典，默认为空，需要用make进行初始化操作(map是引用类型，未初始化的是指向nil，初始化了以后应该就有自己的内存空间了，所以不是nil。)所以返回值为空。 fmt.Printf(\"第一次查看yinzhengjie字典的值：【%v】\\n\",yinzhengjie) yinzhengjie = make(map[string]string) //再使用make函数进行初始化创建一个非nil的map，nil map不能赋值,如果直接赋值会报错：“panic: assignment to entry in nil map” fmt.Printf(\"再次判断yinzhengjie字典是否为空：【%v】\\n\",yinzhengjie == nil) //你就把它理解为一个指针，没初始化就是nil，make之后分配内存了,一旦分配了内存地址就不为空了 fmt.Printf(\"第二次查看yinzhengjie字典的值：【%v】\\n\",yinzhengjie) yinzhengjie[\"name\"] = \"尹正杰\" fmt.Printf(\"yinzhengjie字典的类型为：【%v】\\n\",reflect.TypeOf(yinzhengjie)) fmt.Printf(\"第三次查看yinzhengjie字典的值：【%v】\\n\",yinzhengjie) } #以上代码执行结果如下： 判断yinzhengjie字典是否为空:【true】 第一次查看yinzhengjie字典的值：【map[]】 再次判断yinzhengjie字典是否为空：【false】 第二次查看yinzhengjie字典的值：【map[]】 yinzhengjie字典的类型为：【map[string]string】 第三次查看yinzhengjie字典的值：【map[name:尹正杰]】 map字典直接初始化实例2： package main import \"fmt\" func main() { yinzhengjie := map[string]int{ \"尹正杰\":18, \"饼干\":20, } fmt.Println(yinzhengjie) } #以上代码执行结果如下： map[尹正杰:18 饼干:20] channel初始化实例1： $ cat ch01.go package main import \"fmt\" channel初始化 func main() { c := make(chan int) defer close(c) go func() { c channel初始化实例2： cat ch12.go package main import ( \"fmt\" \"time\" ) func worker(done chan bool) { time.Sleep(time.Second) // 通知任务已完成 done 参考链接： https://www.cnblogs.com/yinzhengjie/p/7689996.html 4. append append(s S, x …T) S Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示： var a []int a = append(a, 1) // 追加1个元素 a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式 a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包 不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。 切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下： var numbers []int for i := 0; i 代码说明如下： 第 1 行，声明一个整型切片。 第 4 行，循环向 numbers 切片中添加 10 个数。 第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。 开头添加元素： var a = []int{1,2,3} a = append([]int{0}, a...) // 在开头添加1个元素 a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片 在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。 中间插入元素 因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素： var a []int a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片 每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。 s = append(s, a) append覆盖 实例1: package main import \"fmt\" func main(){ s := []int{5} s = append(s,7) fmt.Println(\"cap(s) =\", cap(s), \"ptr(s) =\", &s[0]) s = append(s,9) fmt.Println(\"cap(s) =\", cap(s), \"ptr(s) =\", &s[0]) x := append(s, 11) fmt.Println(\"cap(s) =\", cap(s), \"ptr(s) =\", &s[0], \"ptr(x) =\", &x[0]) y := append(s, 12) fmt.Println(\"cap(s) =\", cap(s), \"ptr(s) =\", &s[0], \"ptr(y) =\", &y[0]) } 输出: cap(s) = 2 ptr(s) = 0x10328008 cap(s) = 4 ptr(s) = 0x103280f0 cap(s) = 4 ptr(s) = 0x103280f0 ptr(x) = 0x103280f0 cap(s) = 4 ptr(s) = 0x103280f0 ptr(y) = 0x103280f0 文字说明: 创建s时，cap(s) == 1，内存中数据[5] append(s, 7) 时，按Slice扩容机制，cap(s)翻倍 == 2，内存中数据[5,7] append(s, 9) 时，按Slice扩容机制，cap(s)再翻倍 == 4，内存中数据[5,7,9]，但是实际内存块容量4 x := append(s, 11) 时，容量足够不需要扩容，内存中数据[5,7,9,11] y := append(s, 12) 时，容量足够不需要扩容，内存中数据[5,7,9,12] 5中的append是在s的基础上加入元素12,实际上就是从s切片的末尾开始写入,所以覆盖掉了11 扩展链接： https://learnku.com/articles/38316 5. copy Go内建函数copy: func copy(dst, src []Type) int 用于将源slice的数据（第二个参数），复制到目标slice（第一个参数）。 返回值为拷贝了的数据个数，是len(dst)和len(src)中的最小值。 package main import ( \"fmt\" ) func main() { var a = []int{0, 1, 2, 3, 4, 5, 6, 7} var s = make([]int, 6) //源长度为8，目标为6，只会复制前6个 n1 := copy(s, a) fmt.Println(\"s - \", s) fmt.Println(\"n1 - \", n1) //源长为7，目标为6，复制索引1到6 n2 := copy(s, a[1:]) fmt.Println(\"s - \", s) fmt.Println(\"n2 - \", n2) //源长为8-5=3，只会复制3个值，目标中的后三个值不会变 n3 := copy(s, a[5:]) fmt.Println(\"s - \", s) fmt.Println(\"n3 - \", n3) //将源中的索引5,6,7复制到目标中的索引3,4,5 n4 := copy(s[3:], a[5:]) fmt.Println(\"s - \", s) fmt.Println(\"n4 - \", n4) } 执行结果： s - [0 1 2 3 4 5] n1 - 6 s - [1 2 3 4 5 6] n2 - 6 s - [5 6 7 4 5 6] n3 - 3 s - [5 6 7 5 6 7] n4 - 3 参考链接： https://www.cnblogs.com/baiyuxiong/p/4770978.html 6. delete 删除一个map指定key的元素 delete(m, k) 实例1： $ cat del1.go package main import \"fmt\" func main() { m := map[string]int{ \"a\": 1, \"b\": 2, \"c\": 3, } fmt.Println(\"Deleting values\") name, ok := m[\"a\"] fmt.Println(name,ok) delete(m,\"a\") name,ok = m[\"a\"] fmt.Println(name,ok) } [root@localhost func]# go run del1.go Deleting values 1 true 0 false 7. panic 与 recover panic内置函数停止当前goroutine的正常执行，当函数F调用panic时，函数F的正常执行被立即停止，然后运行所有在F函数中的defer函数，然后F返回到调用他的函数对于调用者G，F函数的行为就像panic一样，终止G的执行并运行G中所defer函数，此过程会一直继续执行到goroutine所有的函数。panic可以通过内置的recover来捕获。 panic(interface{}) 1.defer 表达式的函数如果定义在 panic 后面，该函数在 panic 后就无法被执行到 在defer前panic $ cat panic1.go package main import \"fmt\" func main() { panic(\"a\") defer func() { fmt.Println(\"b\") }() } [root@localhost func]# go run panic1.go //结果，b没有被打印出来 panic: a goroutine 1 [running]: main.main() /root/go/func/panic1.go:4 +0x39 exit status 2 而在defer后panic $ cat panic2.go package main import \"fmt\" func main() { defer func() { fmt.Println(\"b\") }() panic(\"a\") } [root@localhost func]# go run panic2.go ////结果，b被打印出来 b panic: a goroutine 1 [running]: main.main() /root/go/func/panic2.go:8 +0x5f exit status 2 2.F中出现panic时，F函数会立刻终止，不会执行F函数内panic后面的内容，但不会立刻return，而是调用F的defer，如果F的defer中有recover捕获，则F在执行完defer后正常返回，调用函数F的函数G继续正常执行 $ cat panic3.go package main import \"fmt\" func F() { defer func() { if err := recover(); err != nil { fmt.Println(\"捕获异常:\", err) } fmt.Println(\"b\") }() panic(\"a\") } func main() { defer func() { fmt.Println(\"c\") }() F() fmt.Println(\"继续执行\") } [root@localhost func]# go run panic3.go 捕获异常: a b 继续执行 c 3、如果F的defer中无recover捕获，则将panic抛到G中，G函数会立刻终止，不会执行G函数内后面的内容，但不会立刻return，而调用G的defer...以此类推 $ cat panic4.go package main import \"fmt\" func F() { defer func() { fmt.Println(\"b\") }() panic(\"a\") } func main() { defer func() { if err := recover(); err != nil { fmt.Println(\"捕获异常:\", err) } fmt.Println(\"c\") }() F() fmt.Println(\"继续执行\") } [root@localhost func]# go run panic4.go b 捕获异常: a c 4、如果一直没有recover，抛出的panic到当前goroutine最上层函数时，程序直接异常终止 $ cat panic5.go package main import \"fmt\" func F() { defer func() { fmt.Println(\"b\") }() panic(\"a\") } func main() { defer func() { fmt.Println(\"c\") }() F() fmt.Println(\"继续执行\") } [root@localhost func]# go run panic5.go b c panic: a goroutine 1 [running]: main.F() /root/go/func/panic5.go:8 +0x5f main.main() /root/go/func/panic5.go:15 +0x5a exit status 2 5、recover都是在当前的goroutine里进行捕获的，这就是说，对于创建goroutine的外层函数，如果goroutine内部发生panic并且内部没有用recover，外层函数是无法用recover来捕获的，这样会造成程序崩溃 $ cat panic6.go package main import ( \"fmt\" \"time\" ) func F() { defer func() { fmt.Println(\"b\") }() //goroutine内部抛出panic panic(\"a\") } func main() { defer func() { //goroutine外进行recover if err := recover(); err != nil { fmt.Println(\"捕获异常:\", err) } fmt.Println(\"c\") }() //创建goroutine调用F函数 go F() time.Sleep(time.Second) } [root@localhost func]# go run panic6.go b panic: a goroutine 18 [running]: main.F() /root/go/func/panic6.go:12 +0x5f created by main.main /root/go/func/panic6.go:24 +0x5b exit status 2 6.recover返回的是interface{}类型而不是go中的 error 类型，如果外层函数需要调用err.Error()，会编译错误，也可能会在执行时panic $ cat panic7.go package main import ( \"fmt\" \"time\" ) func F() { defer func() { fmt.Println(\"b\") }() panic(\"a\") } func main() { defer func() { if err := recover(); err != nil { fmt.Println(\"捕获异常:\", err.Error()) } fmt.Println(\"c\") }() F() time.Sleep(time.Second) } [root@localhost func]# vim panic7.go [root@localhost func]# go run panic7.go # command-line-arguments ./panic7.go:17:45: err.Error undefined (type interface {} is interface with no methods) 正确实例： $ cat panic7.go package main import ( \"fmt\" \"time\" ) func F() { defer func() { fmt.Println(\"b\") }() panic(\"a\") } func main() { defer func() { if err := recover(); err != nil { fmt.Println(\"捕获异常:\", fmt.Errorf(\"%v\", err).Error()) } fmt.Println(\"c\") }() F() time.Sleep(time.Second) } [root@localhost func]# go run panic7.go b 捕获异常: a c 参考： https://blog.csdn.net/sydnash/article/details/53516524 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_20_method.html":{"url":"Go-Base/go_20_method.html","title":"go 了解方法运用","keywords":"","body":"Go 了解方法运用1. 方法定义1.1 值类型调用1.2 指针型调用1.3 值类型与指针型对比2. 普通函数与方法的区别3. 匿名字段4. 方法集5. 表达式6. 自定义errorGo 了解方法运用 1. 方法定义 Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。 只能为当前包内命名类型定义方法。 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。 不支持方法重载，receiver 只是参数签名的组成部分。 可用实例 value 或 pointer 调用全部方法，编译器自动转换。 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 所有给定类型的方法属于该类型的方法集。 方法定义： func (recevier type)methodName(参数列表)(返回值列表){} 参数和返回值可以省略 package main type Test struct{} // 无参数、无返回值 func (t Test) method0() { } // 单参数、无返回值 func (t Test) method1(i int) { } // 多参数、无返回值 func (t Test) method2(x, y int) { } // 无参数、单返回值 func (t Test) method3() (i int) { return } // 多参数、多返回值 func (t Test) method4(x, y int) (z int, err error) { return } // 无参数、无返回值 func (t *Test) method5() { } // 单参数、无返回值 func (t *Test) method6(i int) { } // 多参数、无返回值 func (t *Test) method7(x, y int) { } // 无参数、单返回值 func (t *Test) method8() (i int) { return } // 多参数、多返回值 func (t *Test) method9(x, y int) (z int, err error) { return } func main() {} 下面定义一个结构体类型和该类型的一个方法： 1.1 值类型调用 package main import ( \"fmt\" ) //结构体 type User struct { Name string Email string } //方法 func (u User) Notify() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } func main() { // 值类型调用方法 u1 := User{\"golang\", \"golang@golang.com\"} u1.Notify() // 指针类型调用方法 u2 := User{\"go\", \"go@go.com\"} u3 := &u2 u3.Notify() } 输出结果： golang : golang@golang.com go : go@go.com 解释： 首先我们定义了一个叫做 User 的结构体类型，然后定义了一个该类型的方法叫做 Notify，该方法的接受者是一个 User 类型的值。要调用 Notify 方法我们需要一个 User 类型的值或者指针。 在这个例子中当我们使用指针时，Go 调整和解引用指针使得调用可以被执行。注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。 我们修改 Notify 方法，让它的接受者使用指针类型： 1.2 指针型调用 package main import ( \"fmt\" ) //结构体 type User struct { Name string Email string } //方法 func (u *User) Notify() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } func main() { // 值类型调用方法 u1 := User{\"golang\", \"golang@golang.com\"} u1.Notify() // 指针类型调用方法 u2 := User{\"go\", \"go@go.com\"} u3 := &u2 u3.Notify() } 输出结果： golang : golang@golang.com go : go@go.com 注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。 方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。 1.3 值类型与指针型对比 package main import \"fmt\" type Data struct { x int } func (self Data) ValueTest() { // func ValueTest(self Data); fmt.Printf(\"Value: %p\\n\", &self) } func (self *Data) PointerTest() { // func PointerTest(self *Data); fmt.Printf(\"Pointer: %p\\n\", self) } func main() { d := Data{} p := &d fmt.Printf(\"Data: %p\\n\", p) d.ValueTest() // ValueTest(d) d.PointerTest() // PointerTest(&d) p.ValueTest() // ValueTest(*p) p.PointerTest() // PointerTest(p) } 输出: Data:0xc42007c008 Value:0xc42007c018 Pointer:0xc42007c008 Value:0xc42007c020 Pointer:0xc42007c008 2. 普通函数与方法的区别 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。 对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。 package main //普通函数与方法的区别（在接收者分别为值类型和指针类型的时候） import ( \"fmt\" ) //1.普通函数 //接收值类型参数的函数 func valueIntTest(a int) int { return a + 10 } //接收指针类型参数的函数 func pointerIntTest(a *int) int { return *a + 10 } func structTestValue() { a := 2 fmt.Println(\"valueIntTest:\", valueIntTest(a)) //函数的参数为值类型，则不能直接将指针作为参数传递 //fmt.Println(\"valueIntTest:\", valueIntTest(&a)) //compile error: cannot use &a (type *int) as type int in function argument b := 5 fmt.Println(\"pointerIntTest:\", pointerIntTest(&b)) //同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递 //fmt.Println(\"pointerIntTest:\", pointerIntTest(&b)) //compile error:cannot use b (type int) as type *int in function argument } //2.方法 type PersonD struct { id int name string } //接收者为值类型 func (p PersonD) valueShowName() { fmt.Println(p.name) } //接收者为指针类型 func (p *PersonD) pointShowName() { fmt.Println(p.name) } func structTestFunc() { //值类型调用方法 personValue := PersonD{101, \"hello world\"} personValue.valueShowName() personValue.pointShowName() //指针类型调用方法 personPointer := &PersonD{102, \"hello golang\"} personPointer.valueShowName() personPointer.pointShowName() //与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用 } func main() { structTestValue() structTestFunc() } 输出结果： valueIntTest:12 pointerIntTest:15 hello world hello world hello golang hello golang 3. 匿名字段 可以像字段成员那样访问匿名字段方法，编译器负责查找。 package main import \"fmt\" type User struct { id int name string } type Manager struct { User } func (self *User) ToString() string { // receiver = &(Manager.User) return fmt.Sprintf(\"User: %p, %v\", self, self) } func main() { m := Manager{User{1, \"Tom\"}} fmt.Printf(\"Manager: %p\\n\", &m) fmt.Println(m.ToString()) } 输出结果: Manager:0xc42000a060 User:0xc42000a060,&{1 Tom} 通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。 package main import \"fmt\" type User struct { id int name string } type Manager struct { User title string } func (self *User) ToString() string { return fmt.Sprintf(\"User: %p, %v\", self, self) } func (self *Manager) ToString() string { return fmt.Sprintf(\"Manager: %p, %v\", self, self) } func main() { m := Manager{User{1, \"Tom\"}, \"Administrator\"} fmt.Println(m.ToString()) fmt.Println(m.User.ToString()) } 输出结果: Manager:0xc420074180,&{{1 Tom} Administrator} User:0xc420074180,&{1 Tom} 4. 方法集 每个类型都有与之关联的方法集，这会影响到接口实现规则。 类型 T 方法集包含全部 receiver T 方法。 类型 T 方法集包含全部 receiver T +T 方法。 *如类型 S 包含匿名字段 T，则 S 和 S 方法集包含 T 方法** 如类型 S 包含匿名字段 T，则 S 和 S 方法集包含 T +T 方法。* 不管嵌入 T 或 T，S 方法集总是包含 T +T 方法。* 用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。 Go 语言中内部类型方法集提升的规则 类型 T 方法集包含全部 receiver T 方法。 package main import ( \"fmt\" ) type T struct { int } func (t T) test() { fmt.Println(\"类型 T 方法集包含全部 receiver T 方法。\") } func main() { t1 := T{1} fmt.Printf(\"t1 is : %v\\n\", t1) t1.test() } 输出结果： t1 is :{1} 类型 T 方法集包含全部 receiver T 方法。 类型 T 方法集包含全部 receiver T + T 方法。 package main import ( \"fmt\" ) type T struct { int } func (t T) testT() { fmt.Println(\"类型 *T 方法集包含全部 receiver T 方法。\") } func (t *T) testP() { fmt.Println(\"类型 *T 方法集包含全部 receiver *T 方法。\") } func main() { t1 := T{1} t2 := &t1 fmt.Printf(\"t2 is : %v\\n\", t2) t2.testT() t2.testP() } 输出结果： t2 is :&{1} 类型 T 方法集包含全部 receiver T 方法。 类型 T 方法集包含全部 receiver *T 方法。 给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中： 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。 package main import ( \"fmt\" ) type S struct { T } type T struct { int } func (t T) testT() { fmt.Println(\"如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。\") } func main() { s1 := S{T{1}} s2 := &s1 fmt.Printf(\"s1 is : %v\\n\", s1) s1.testT() fmt.Printf(\"s2 is : %v\\n\", s2) s2.testT() } 输出结果： s1 is :{{1}} 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 s2 is :&{{1}} 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 如类型 S 包含匿名字段 T，则 S 和 S 方法集包含 T + *T 方法。 这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。 package main import ( \"fmt\" ) type S struct { T } type T struct { int } func (t T) testT() { fmt.Println(\"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法\") } func (t *T) testP() { fmt.Println(\"如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法\") } func main() { s1 := S{T{1}} s2 := &s1 fmt.Printf(\"s1 is : %v\\n\", s1) s1.testT() s1.testP() fmt.Printf(\"s2 is : %v\\n\", s2) s2.testT() s2.testP() } 输出结果： s1 is :{{1}} 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法 s2 is :&{{1}} 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法 5. 表达式 根据调用者不同，方法分为两种表现形式: instance.method(args...)--->.func(instance, args...) 前者称为 method value，后者 method expression。 两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。 package main import \"fmt\" type User struct { id int name string } func (self *User) Test() { fmt.Printf(\"%p, %v\\n\", self, self) } func main() { u := User{1, \"Tom\"} u.Test() mValue := u.Test mValue() // 隐式传递 receiver mExpression := (*User).Test mExpression(&u) // 显式传递 receiver } 输出结果: 0xc42000a060,&{1 Tom} 0xc42000a060,&{1 Tom} 0xc42000a060,&{1 Tom} 需要注意，method value 会复制 receiver。 package main import \"fmt\" type User struct { id int name string } func (self User) Test() { fmt.Println(self) } func main() { u := User{1, \"Tom\"} mValue := u.Test // 立即复制 receiver，因为不是指针类型，不受后续修改影响。 u.id, u.name = 2, \"Jack\" u.Test() mValue() } 输出结果: {2 Jack} {1 Tom} 在汇编层面，method value 和闭包的实现方式相同，实际返回 FuncVal 类型对象。 FuncVal { method_address, receiver_copy } 可依据方法集转换 method expression，注意 receiver 类型的差异。 package main import \"fmt\" type User struct { id int name string } func (self *User) TestPointer() { fmt.Printf(\"TestPointer: %p, %v\\n\", self, self) } func (self User) TestValue() { fmt.Printf(\"TestValue: %p, %v\\n\", &self, self) } func main() { u := User{1, \"Tom\"} fmt.Printf(\"User: %p, %v\\n\", &u, u) mv := User.TestValue mv(u) mp := (*User).TestPointer mp(&u) mp2 := (*User).TestValue // *User 方法集包含 TestValue。签名变为 func TestValue(self *User)。实际依然是 receiver value copy。 mp2(&u) } 输出: User:0xc42000a060,{1 Tom} TestValue:0xc42000a0a0,{1 Tom} TestPointer:0xc42000a060,&{1 Tom} TestValue:0xc42000a100,{1 Tom} 将方法 “还原” 成函数，就容易理解下面的代码了。 package main type Data struct{} func (Data) TestValue() {} func (*Data) TestPointer() {} func main() { var p *Data = nil p.TestPointer() (*Data)(nil).TestPointer() // method value (*Data).TestPointer(nil) // method expression // p.TestValue() // invalid memory address or nil pointer dereference // (Data)(nil).TestValue() // cannot convert nil to type Data // Data.TestValue(nil) // cannot use nil as type Data in function argument } 6. 自定义error package main import ( \"fmt\" \"os\" \"time\" ) type PathError struct { path string op string createTime string message string } func (p *PathError) Error() string { return fmt.Sprintf(\"path=%s \\nop=%s \\ncreateTime=%s \\nmessage=%s\", p.path, p.op, p.createTime, p.message) } func Open(filename string) error { file, err := os.Open(filename) if err != nil { return &PathError{ path: filename, op: \"read\", message: err.Error(), createTime: fmt.Sprintf(\"%v\", time.Now()), } } defer file.Close() return nil } func main() { err := Open(\"/Users/***/Desktop/go/src/test.txt\") switch v := err.(type) { case *PathError: fmt.Println(\"get path error,\", v) default: } } 输出结果： get path error, path=/Users/***/Desktop/go/src/test.txt op=read createTime=2018-04-0511:25:17.331915+0800 CST m=+0.000441790 message=open /Users/***/Desktop/go/src/test.txt: no such file or directory 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch5.5.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_21_interface.html":{"url":"Go-Base/go_21_interface.html","title":"go 了解接口运用","keywords":"","body":"Go 了解接口运用1. 接口定义2. 接口类型值3. nil 接口值4. 实现接口4.1 单接口单方法4.2 单节口多方法4.3 多接口多方法4.4 多接口多方法（嵌套接口）4.5 空接口5. 指针接收者和值接收者实现接口区别6. 匿名接口7. 类型断言8. 类型转换Go 了解接口运用 1. 接口定义 Go 语言中的接口很特别，而且提供了难以置信的一系列灵活性和抽象性。指定一个特定类型的值和指针表现为特定的方式。从语言角度看，接口是一种类型，它指定一个方法集，所有方法为接口类型就被认为是该接口。 interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。 interface类型默认是一个指针 interface语法： type example interface{ Method1(参数列表) 返回值列表 Method2(参数列表) 返回值列表 … } var a example a.Method1() 实际定义一个接口： type Shape interface { Area() float32 } 上面的代码定义了接口类型 Shape，接口中包含了一个不带参数、返回值为 float32 的方法 Area()。任何实现了方法 Area() 的类型 T，我们就说它实现了接口 Shape。 inter1.go type Shape interface { Area() float32 } func main() { var s Shape fmt.Println(\"value of s is\", s) fmt.Printf(\"type of s is %T\\n\", s) } 输出： value of s is type of s is 上面的代码，由于接口是一种类型，所以可以创建 Shape 类型的变量 s，你是不是很疑惑 s 的类型为什么是 nil？让我们来看下一节！ 2. 接口类型值 第一种解释 变量的类型在声明时指定、且不能改变，称为静态类型。接口类型的静态类型就是接口本身。接口没有静态值，它指向的是动态值。接口类型的变量存的是实现接口的类型的值。该值就是接口的动态值，实现接口的类型就是接口的动态类型。 第二种解释 Golang 接口执行机制 ：接口对象由接口表 (interface table) 指针和数据指针组成。 inter2.go type Iname interface { Mname() } type St1 struct {} func (St1) Mname() {} type St2 struct {} func (St2) Mname() {} func main() { var i Iname = St1{} fmt.Printf(\"type is %T\\n\",i) fmt.Printf(\"value is %v\\n\",i) i = St2{} fmt.Printf(\"type is %T\\n\",i) fmt.Printf(\"value is %v\\n\",i) } 复制代码输出： type is main.St1 value is {} type is main.St2 value is {} 变量 i 的静态类型是 Iname，是不能改变的。动态类型却是不固定的，第一次分配之后，i 的动态类型是 St1，第二次分配之后，i 的动态类型是 St2，动态值都是空结构体。 有时候，接口的动态类型又称为具体类型，当我们访问接口类型的时候，返回的是底层动态值的类型。 只能修改方法指针改变对象值 package main import \"fmt\" type User struct { id int name string } func main() { u := User{1, \"Tom\"} var i interface{} = u u.id = 2 u.name = \"Jack\" //使用T修改值 fmt.Printf(\"%v\\n\", u) fmt.Printf(\"%v\\n\", i.(User)) } 输出结果: {2 Jack} {1 Tom} 接口转型返回临时对象，只有使用指针才能修改其状态。 package main import \"fmt\" type User struct { id int name string } func main() { u := User{1, \"Tom\"} var vi, pi interface{} = u, &u // vi.(User).name = \"Jack\" // Error: cannot assign to vi.(User).name pi.(*User).name = \"Jack\" //使用*T修改值 fmt.Printf(\"%v\\n\", vi.(User)) fmt.Printf(\"%v\\n\", pi.(*User)) } 输出结果: {1 Tom} &{1 Jack} 3. nil 接口值 inter3.go type Iname interface { Mname() } type St struct {} func (St) Mname() {} func main() { var t *St if t == nil { fmt.Println(\"t is nil\") } else { fmt.Println(\"t is not nil\") } var i Iname = t fmt.Printf(\"%T\\n\", i) if i == nil { fmt.Println(\"i is nil\") } else { fmt.Println(\"i is not nil\") } fmt.Printf(\"i is nil pointer:%v\",i == (*St)(nil)) } 输出： t is nil *main.St i is not nil i is nil pointer:true 是不是很惊讶，我们分配给变量 i 的值明明是 nil，然而 i 却不是 nil。 来看下怎么回事！ 动态类型在上面已经讲过，动态值是实际分配的值。记住一点：当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。上面的代码，给变量 i 赋值之后，i 的动态值是 nil，但是动态类型却是 St， i 是一个 nill 指针，所以相等条件不成立。 *看下 Go 语言规范： var x interface{} = struct() var x interface{} // x is nil and has static type interface{} var v *T // v has value nil, static type *T x = 42 // x has value 42 and dynamic type int x = v // x has value (*T)(nil) and dynamic type *T 通过这一节学习，相信你已经很清楚为什么上一节的 Shape 类型的变量的 s 输出的类型是 nil，因为 var s Shape 声明时，s 的动态类型是 nil。 4. 实现接口 4.1 单接口单方法 inter4.go type Shape interface { Area() float32 } type Rect struct { width float32 height float32 } func (r Rect) Area() float32 { return r.width * r.height } func main() { var s Shape s = Rect{5.0, 4.0} r := Rect{5.0, 4.0} fmt.Printf(\"type of s is %T\\n\", s) fmt.Printf(\"value of s is %v\\n\", s) fmt.Println(\"area of rectange s\", s.Area()) fmt.Println(\"s == r is\", s == r) } 输出： type of s is main.Rect value of s is {5 4} area of rectange s 20 s == r is true 创建了接口 Shape、结构体 Rect 以及方法 Area()。由于 Rect 实现了接口定义的所有方法，虽然只有一个，所以说 Rect 实现了接口 Shape。 在主函数里，创建了接口类型的变量 s ，值为 nil，并用 Rect 类型的结构体初始化，因为 Rect 结构体实现了接口，所以这是有效的。赋值之后，s 的动态类型变成了 Rect，动态值就是结构体的值 {5.0,4.0}。 可以直接使用 . 语法调用 Area() 方法，因为 s 的具体类型是 Rect，而 Rect 实现了 Area() 方法。 4.2 单节口多方法 inter4.go package main import ( \"fmt\" ) type I interface { Method1() int Method2() string } type S struct { name string age int } func (s S) Method1() int { return s.age } func (s S) Method2() string { return s.name } func main() { var user I = S{\"Murphy\", 28} age := user.Method1() name := user.Method2() fmt.Println(age, name) } 输出结果： 28 Murphy 4.3 多接口多方法 inter5-1.go type Shape interface { Area() float32 } type Object interface { Perimeter() float32 } type Circle struct { radius float32 } func (c Circle) Area() float32 { return math.Pi * (c.radius * c.radius) } func (c Circle) Perimeter() float32 { return 2 * math.Pi * c.radius } func main() { c := Circle{3} var s Shape = c var p Object = c fmt.Println(\"area: \", s.Area()) fmt.Println(\"perimeter: \", p.Perimeter()) } 输出： area: 28.274334 perimeter: 18.849556 4.4 多接口多方法（嵌套接口） inter5-2.go type Math interface { Shape Object } type Shape interface { Area() float32 } type Object interface { Perimeter() float32 } type Circle struct { radius float32 } func (c Circle) Area() float32 { return math.Pi * (c.radius * c.radius) } func (c Circle) Perimeter() float32 { return 2 * math.Pi * c.radius } func main() { c := Circle{3} var m Math = c fmt.Printf(\"%T\\n\", m ) fmt.Println(\"area: \", m.Area()) fmt.Println(\"perimeter: \", m.Perimeter()) } 输出： main.Circle area: 28.274334 perimeter: 18.849556 4.5 空接口 一个不包含任何方法的接口，称之为空接口，形如：interface{}。因为空接口不包含任何方法，所以任何类型都默认实现了空接口。 举个例子，fmt 包中的 Println() 函数，可以接收多种类型的值，比如：int、string、array等。为什么，因为它的形参就是接口类型，可以接收任意类型的值。 inter6-1.go第一种 package main import \"fmt\" func Print(v interface{}) { fmt.Printf(\"%T: %v\\n\", v, v) } func main() { Print(1) Print(\"Hello, World!\") } 输出： int: 1 string: Hello, World! inter6-2.go第二种 func Println(a ...interface{}) (n int, err error) {} type MyString string type Rect struct { width float32 height float32 } func explain(i interface{}) { fmt.Printf(\"type of s is %T\\n\", i) fmt.Printf(\"value of s is %v\\n\\n\", i) } func main() { ms := MyString(\"Seekload\") r := Rect{5.0, 4.0} explain(ms) explain(r) } 输出： type of s is main.MyString value of s is Seekload type of s is main.Rect value of s is {5 4} 上面的代码，创建了自定义的字符串类型 MyString 、结构体 Rect 和 explain() 函数。explain() 函数的形参是空接口，所以可以接收任意类型的值。 5. 指针接收者和值接收者实现接口区别 inter7.go type Shape interface { Area() float32 } type Circle struct { radius float32 } type Square struct { side float32 } func (c Circle) Area() float32 { return math.Pi * (c.radius * c.radius) } func (s *Square) Area() float32 { return s.side * s.side } func main() { var s Shape c1 := Circle{3} s = c1 fmt.Printf(\"%v\\n\",s.Area()) c2 := Circle{4} s = &c2 fmt.Printf(\"%v\\n\",s.Area()) c3 := Square{3} //s = c3 s = &c3 fmt.Printf(\"%v\\n\",s.Area()) } 输出： 28.274334 50.265484 9 上面的代码，结构体 Circle 通过值接收者实现了接口 Shape。我们在方法那篇文章中已经讨论过了，值接收者的方法可以使用值或者指针调用，所以上面的 c1 和 c2 的调用方式是合法的。 结构体 Square 通过指针接收者实现了接口 Shape。如果将上方注释部分打开的话，编译就会出错： cannot use c3 (type Square) as type Shape in assignment: Square does not implement Shape (Area method has pointer receiver) 从报错提示信息可以清楚看出，此时我们尝试将值类型 c3 分配给 s，但 c3 并没有实现接口 Shape。这可能会令我们有点惊讶，因为在方法中，我们可以直接通过值类型或者指针类型调用指针接收者方法。 记住一点：对于指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口存储的具体值是不可寻址的，对于编译器无法自动获取 c3 的地址，于是程序报错。 6. 匿名接口 匿名接口可用作变量类型，或结构成员 *inter8.go package main import \"fmt\" type Tester struct { s interface { String() string } } type User struct { id int name string } func (self *User) String() string { return fmt.Sprintf(\"user %d, %s\", self.id, self.name) } func main() { t := Tester{&User{1, \"Tom\"}} fmt.Println(t.s.String()) } 输出结果: user 1, Tom 7. 类型断言 一个 interface 被多种类型实现时，有时候我们需要区分 interface 的变量究竟存储哪种类型的值，go 可以使用 comma, ok 的形式做区分 value, ok := em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。 Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁 if t, ok := i.(*S); ok { fmt.Println(\"s implements I\", t) } ok 是 true 表明 i 存储的是 *S 类型的值，false 则不是，这种区分能力叫 Type assertions (类型断言)。 如果需要区分多种类型，可以使用 switch 断言，更简单直接，这种断言方式只能在 switch 语句中使用。 inter9-1.go switch t := i.(type) { case *S: fmt.Println(\"i store *S\", t) case *R: fmt.Println(\"i store *R\", t) } 8. 类型转换 inter10-1.go var s int var x interface x = s y , ok := x.(int) //将interface 转为int,ok可省略 但是省略以后转换失败会报错，true转换成功，false转换失败, 并采用默认值 inter10-2.go package main import \"fmt\" func main() { var x interface{} s := \"WD\" x = s y,ok := x.(int) z,ok1 := x.(string) fmt.Println(y,ok) fmt.Println(z,ok1) } //0 false //WD true inter10-3.go package main import \"fmt\" type Student struct { Name string } func TestType(items ...interface{}) { for k, v := range items { switch v.(type) { case string: fmt.Printf(\"type is string, %d[%v]\\n\", k, v) case bool: fmt.Printf(\"type is bool, %d[%v]\\n\", k, v) case int: fmt.Printf(\"type is int, %d[%v]\\n\", k, v) case float32, float64: fmt.Printf(\"type is float, %d[%v]\\n\", k, v) case Student: fmt.Printf(\"type is Student, %d[%v]\\n\", k, v) case *Student: fmt.Printf(\"type is Student, %d[%p]\\n\", k, v) } } } func main() { var stu Student TestType(\"WD\", 100, stu,3.3) } //type is string, 0[WD] //type is int, 1[100] //type is Student, 2[{}] //type is float, 3[3.3] 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch6.md https://juejin.im/post/5c9d5631f265da60d82dde9c Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_22_panic_and_recover.html":{"url":"Go-Base/go_22_panic_and_recover.html","title":"go panic 与 recover 异常处理","keywords":"","body":"Go panic 与 recover 异常处理1. 异常处理2. panic3. recover4. 如何区别使用 panic 和 error 两种方式Go panic 与 recover 异常处理 1. 异常处理 Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。 异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。 2. panic 1、内置函数 2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行 4、直到goroutine整个退出，并报告错误 3. recover 1、内置函数 2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 3、一般的调用建议 a). 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行 b). 可以获取通过panic传递的error 注意:（最重要） 1.利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。 2.recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。 3.多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。 $ cat error1.go package main func main() { test() } func test() { defer func() { if err := recover(); err != nil { println(err.(string)) // 将 interface{} 转型为具体类型。 } }() panic(\"panic error!\") } [root@localhost error]# go run error1.go panic error! 由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象。 func panic(v interface{}) func recover() interface{} 向已关闭的通道发送数据会引发panic $ cat error2.go package main import ( \"fmt\" ) func main() { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() var ch chan int = make(chan int, 10) close(ch) ch 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。 $ cat error3.go package main import \"fmt\" func test() { defer func() { fmt.Println(recover()) }() defer func() { panic(\"defer panic\") }() panic(\"test panic\") } func main() { test() } [root@localhost error]# go run error3.go defer panic 捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。 $ cat error4.go package main import \"fmt\" func test() { defer func() { fmt.Println(recover()) //有效 }() defer recover() //无效！ defer fmt.Println(recover()) //无效！ defer func() { func() { println(\"defer inner\") recover() //无效！ }() }() panic(\"test panic\") } func main() { test() } [root@localhost error]# go run error4.go defer inner test panic 使用延迟匿名函数或下面这样都是有效的。 $ cat error5.go package main import ( \"fmt\" ) func except() { fmt.Println(recover()) } func test() { defer except() panic(\"test panic\") } func main() { test() } [root@localhost error]# go run error5.go test panic 如果需要保护代码段，可将代码块重构成匿名函数，如此可确保后续代码被执 。 cat error6.go package main import \"fmt\" func test(x, y int) { var z int func() { defer func() { if recover() != nil { z = 0 } }() panic(\"test panic\") z = x / y return }() fmt.Printf(\"x / y = %d\\n\", z) } func main() { test(2, 1) } [root@localhost error]# go run error6.go x / y = 0 标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。 $ cat error7.go package main import ( \"errors\" \"fmt\" ) var ErrDivByZero = errors.New(\"division by zero\") func div(x, y int) (int, error) { if y == 0 { return 0, ErrDivByZero } return x / y,nil } func main() { defer func() { fmt.Println(recover()) }() switch z,err := div(10, 0); err { case nil: fmt.Println(z) case ErrDivByZero: panic(err) } } [root@localhost error]# go run error7.go division by zero Go实现类似 try catch 的异常处理 package main import \"fmt\" func Try(fun func(), handler func(interface{})) { defer func() { if err := recover(); err != nil { handler(err) } }() fun() } func main() { Try(func() { panic(\"test panic\") }, func(err interface{}) { fmt.Println(err) }) } 输出结果： test panic 4. 如何区别使用 panic 和 error 两种方式 惯例是:导致关键流程出现不可修复性错误的使用 panic，其他使用 error。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_23_defer.html":{"url":"Go-Base/go_23_defer.html","title":"go defer 延迟调用","keywords":"","body":"Go defer 延迟调用1. 简介2. 原则3. defer 特性4. defer 用途5. defer 陷阱6. defer nil 函数7. 错误的位置使用 defer(未通过验证)Go defer 延迟调用 1. 简介 defer关键字的作用是当外围函数返回之后才执行被推迟的函数。在文件输入输出操作中经常可以见到 defer关键字，因为它使您不必记住何时关闭已打开的文件：defer关键字调用文件关闭函数关闭已打开 的文件时，可以紧靠着文件打开函数之后 2. 原则 defer函数在外围函数返回之后，以后进先出(LIFO)的原则执行。简单点 说，在一个外围函数中有3个defer函数： f1() 最先出现，然后 f2() ，最后 f3() ，当外围函数执行返回之后， f3() 最先被执行，接着是 f2() ，最后是 f1() 3. defer 特性 关键字 defer 用于注册延迟调用。 这些调用直到 return 前才被执。因此，可以用来做资源清理。 多个defer语句，按先进后出的方式执行。 defer语句中的变量，在defer声明时就决定了。 4. defer 用途 关闭文件句柄 锁资源释放 数据库连接释放 go语言 defer go 语言的defer功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。 defer 是先进后出 这个很自然,后面的语句会依赖前面的资源，因此如果先前面的资源先释放了，后面的语句就没法执行了 $ cat defer1.go package main import \"fmt\" func main(){ var whatever [5]struct{} for i := range whatever { defer fmt.Println(i)} } [root@localhost defer]# go run defer1.go 4 3 2 1 0 defer 碰上闭包 $ cat defer2.go package main import \"fmt\" func main(){ var whatever [5]struct{} for i := range whatever { defer func(){ fmt.Println(i)}()}} [root@localhost defer]# go run defer2.go 4 4 4 4 4 其实go说的很清楚,我们一起来看看go spec如何说的 Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked. 也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4. defer f.Close 这个大家用的都很频繁,但是go语言编程举了一个可能一不小心会犯错的例子. $ cat defer3.go package main import \"fmt\" type Test struct { name string } func (t *Test)Close(){ fmt.Println(t.name,\" closed\") } func main(){ ts :=[]Test{{\"a\"},{\"b\"},{\"c\"}} for _, t := range ts { defer t.Close() } } [root@localhost defer]# go run defer3.go c closed c closed c closed 这个输出并不会像我们预计的输出c b a,而是输出c c c 可是按照前面的go spec中的说明,应该输出c b a才对啊. 那我们换一种方式来调用一下. $ cat defer4.go package main import \"fmt\" type Test struct { name string } func (t *Test)Close(){ fmt.Println(t.name,\" closed\") } func Close(t Test){ t.Close() } func main(){ ts :=[]Test{{\"a\"},{\"b\"},{\"c\"}} for _, t := range ts { defer Close(t) } } [root@localhost defer]# go run defer4.go c closed b closed a closed 这个时候输出的就是c b a 当然,如果你不想多写一个函数,也很简单,可以像下面这样,同样会输出c b a 看似多此一举的声明 $ cat defer5.go package main import \"fmt\" type Test struct { name string } func (t *Test)Close(){ fmt.Println(t.name,\" closed\") } func main(){ ts :=[]Test{{\"a\"},{\"b\"},{\"c\"}} for _, t := range ts { t2 := t defer t2.Close() } } [root@localhost defer]# go run defer5.go c closed b closed a closed 通过以上例子，结合 Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usualand saved anew but the actual function is not invoked. 这句话。可以得出下面的结论： defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。 多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。 $ cat defer6.go package main func test(x int){ defer println(\"a\") defer println(\"b\") defer func(){ println(100/ x)// div0 异常未被捕获，逐步往外传递，最终终止进程。 }() defer println(\"c\") } func main(){ test(0) } [root@localhost defer]# go run defer6.go c b a panic: runtime error: integer divide by zero goroutine 1 [running]: main.test.func1(0x0) /root/go/defer/defer6.go:6 +0x6f main.test(0x0) /root/go/defer/defer6.go:9 +0x140 main.main() /root/go/defer/defer6.go:11 +0x2a exit status 2 延迟调用参数在注册时求值或复制，可用指针或闭包 “延迟” 读取。(*未通过) package main func test() func() { x, y :=10,20 defer func(i int){println(\"defer:\", i, y)// y 闭包引用}(x)// x 被复制 x +=10 y +=100println(\"x =\", x,\"y =\", y) } func main(){ test() } 输出结果: x =20 y =120 defer:10120 *滥用 defer 可能会导致性能问题，尤其是在一个 “大循环” 里。 $ cat defer8.go package main import ( \"fmt\" \"sync\" \"time\" ) var lock sync.Mutex func test(){ lock.Lock() lock.Unlock() } func testdefer(){ lock.Lock() defer lock.Unlock() } func main(){ func(){ t1 := time.Now() for i :=0; i 5. defer 陷阱 defer 与 closure $ cat defer10.go package main import ( \"errors\" \"fmt\" ) func foo(a, b int)(i int, err error){ defer fmt.Printf(\"first defer err %v\\n\", err) defer func(err error){ fmt.Printf(\"second defer err %v\\n\", err) }(err) defer func(){ fmt.Printf(\"third defer err %v\\n\", err)}() if b ==0{ err = errors.New(\"divided by zero!\") return } i = a / b return} func main(){ foo(2,0) } [root@localhost defer]# go run defer10.go third defer err divided by zero! second defer err first defer err 解释：如果 defer 后面跟的不是一个 closure 最后执行的时候我们得到的并不是最新的值。 $ cat defer11.go package main import \"fmt\" func foo()(i int){ i =0 defer func(){ fmt.Println(i)}() return 2 } func main(){foo()} [root@localhost defer]# go run defer11.go 2 解释：在有具名返回值的函数中（这里具名返回值为 i），执行 return 2 的时候实际上已经将 i 的值重新赋值为 2。所以defer closure 输出结果为 2 而不是 1。 6. defer nil 函数 $ cat defer12.go package main import (\"fmt\") func test(){ var run func()= nil defer run() fmt.Println(\"runs\")} func main(){ defer func(){if err :=recover(); err != nil { fmt.Println(err)}}() test() } [root@localhost defer]# go run defer12.go runs runtime error: invalid memory address or nil pointer dereference 解释：名为 test 的函数一直运行至结束，然后 defer 函数会被执行且会因为值为 nil 而产生 panic 异常。然而值得注意的是，run() 的声明是没有问题，因为在test函数运行完成后它才会被调用。 7. 错误的位置使用 defer(未通过验证) 当 http.Get 失败时会抛出异常。 package main import \"net/http\" func do() error { res, err := http.Get(\"http://www.google.com\") defer res.Body.Close()if err != nil {return err }// ..code...return nil } func main(){do()} 输出结果： panic: runtime error: invalid memory address or nil pointer dereference 因为在这里我们并没有检查我们的请求是否成功执行，当它失败的时候，我们访问了 Body 中的空变量 res ，因此会抛出异常 解决方案 总是在一次成功的资源分配下面使用 defer ，对于这种情况来说意味着：当且仅当 http.Get 成功执行时才使用 defer。 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch4.6.md Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_24_goroutine.html":{"url":"Go-Base/go_24_goroutine.html","title":"go 了解 goroutine 运用","keywords":"","body":"Go 了解 goroutine 运用1. goroutine 原理2. CSP并发模型3. Goroutine 调度器4. 方法5. goroutine异常捕捉6. 同步的goroutine(?)7. goroutine之间的通讯(?)Go 了解 goroutine 运用 1. goroutine 原理 在 Go 语言中，通过协程和管道实现了 Communicating Sequential Processes, CSP 模型，两者承担了通信和同步中的重要角色。 2. CSP并发模型 CSP模型是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。 Golang 就是借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有，完全实现了CSP模型的所有理论，仅仅是借用了 process和channel这两个概念。process是在go语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。 Golang中使用 CSP中 channel 这个概念。channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实是一个阻塞的消息队列。 Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点： 用户空间 避免了内核态和用户态的切换导致的成本 可以由语言和框架层进行调度 更小的栈空间允许创建大量的实例 3. Goroutine 调度器 golang使用goroutine做为最小的执行单位，但是这个执行单位还是在用户空间，实际上最后被处理器执行的还是内核中的线程。 用户线程和内核线程的调度方法有： 多个用户线程对应一个内核线程 一个用户线程对应一个内核线程 用户线程和内核线程是多对多的对应关系 golang 通过为goroutine提供语言层面的调度器，来实现了高效率的M:N线程对应关系 支撑整个调度器的主要有4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中 M：是内核线程 P : 是调度协调，用于协调M和G的执行，内核线程只有拿到了P才能对goroutine继续调度执行，一般都是通过限定P的个数来控制golang的并发度，P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。 图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue）， Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个 goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。 G : 是待执行的goroutine，包含这个goroutine的栈空间 Gn : 灰色背景的Gn 是已经挂起的goroutine，它们被添加到了执行队列中，然后需要等待网络IO的goroutine，当P通过 epoll查询到特定的fd的时候，会重新调度起对应的，正在挂起的goroutine。 Golang为了调度的公平性，在调度器加入了steal working 算法 ，在一个P自己的执行队列，处理完之后，它会先到全局的执行队列中偷G进行处理，如果没有的话，再会到其他P的执行队列中抢G来进行处理。 当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。 当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来， 如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。 另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任务，此时如果global runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的使用，如下图： 参考地址：http://morsmachine.dk/go-scheduler 4. 方法 设置goroutine运行的CPU数量，最新版本的go已经默认已经设置了。 num := runtime.NumCPU() //获取主机的逻辑CPU个数 runtime.GOMAXPROCS(num) //设置可同时执行的最大CPU数 $ cat go1.go package main import ( \"fmt\" \"time\" ) func cal(a int , b int) { c := a+b fmt.Printf(\"%d + %d = %d\\n\",a,b,c) } func main() { for i :=0 ; i 5. goroutine异常捕捉 当启动多个goroutine时，如果其中一个goroutine异常了，并且我们并没有对进行异常处理，那么整个程序都会终止，所以我们在编写程序时候最好每个goroutine所运行的函数都做异常处理，异常处理采用recover package main import ( \"fmt\" \"time\" ) func addele(a []int ,i int) { defer func() { //匿名函数捕获错误 err := recover() if err != nil { fmt.Println(\"add ele fail\") } }() a[i]=i fmt.Println(a) } func main() { Arry := make([]int,4) for i :=0 ; i 6. 同步的goroutine(?) 由于goroutine是异步执行的，那很有可能出现主程序退出时还有goroutine没有执行完，此时goroutine也会跟着退出。此时如果想等到所有goroutine任务执行完毕才退出，go提供了sync包和channel来解决同步问题，当然如果你能预测每个goroutine执行的时间，你还可以通过time.Sleep方式等待所有的groutine执行完成以后在退出程序(如上面的列子)。 示例一：使用sync包同步goroutine sync大致实现方式 WaitGroup 等待一组goroutinue执行完毕. 主程序调用 Add 添加等待的goroutinue数量. 每个goroutinue在执行结束时调用 Done ，此时等待队列数量减1.，主程序通过Wait阻塞，直到等待队列为0. package main import ( \"fmt\" \"sync\" ) func cal(a int , b int ,n *sync.WaitGroup) { c := a+b fmt.Printf(\"%d + %d = %d\\n\",a,b,c) defer n.Done() //goroutinue完成后, WaitGroup的计数-1 } func main() { var go_sync sync.WaitGroup //声明一个WaitGroup变量 for i :=0 ; i 示例二：通过channel实现goroutine之间的同步。 实现方式：通过channel能在多个groutine之间通讯，当一个goroutine完成时候向channel发送退出信号,等所有goroutine退出时候，利用for循环channe去channel中的信号，若取不到数据会阻塞原理，等待所有goroutine执行完毕，使用该方法有个前提是你已经知道了你启动了多少个goroutine。 package main import ( \"fmt\" \"time\" ) func cal(a int , b int ,Exitchan chan bool) { c := a+b fmt.Printf(\"%d + %d = %d\\n\",a,b,c) time.Sleep(time.Second*2) Exitchan 7. goroutine之间的通讯(?) goroutine本质上是协程，可以理解为不受内核调度，而受go调度器管理的线程。goroutine之间可以通过channel进行通信或者说是数据共享，当然你也可以使用全局变量来进行数据共享。 示例：使用channel模拟消费者和生产者模式 package main import ( \"fmt\" \"sync\" ) func Productor(mychan chan int,data int,wait *sync.WaitGroup) { mychan 参考： https://www.cnblogs.com/wdliu/p/9272220.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_25_channel.html":{"url":"Go-Base/go_25_channel.html","title":"go 了解 channel 管道","keywords":"","body":"Go 了解 channel 管道1.channel概念2.channel语法2.1 var 变量名 chan 类型2.2 channel方向2.3 send发送（先进）2.4 receive 接受（先出）3. make进行初始化4. 不同类型channel写入、读取5. 判断channel6. channel 写入、读取7. close()处理chan8. range 遍历 chan9. 内置函数len()、cap()处理chan10. select处理chan11. timeout处理chan12. chan的只读和只写12.1 只读chan的声明12.2 只写chan的声明13. channel单向14. channel传参Go 了解 channel 管道 1.channel概念 协程是并发编程的基础，而管道（channel）则是并发中协程之间沟通的桥梁，很多时候我们启动一个协程去执行完一个操作，执行操作之后我们需要返回结果，或者多个协程之间需要相互协作 a. 类似unix中管道（pipe） b. 先进先出 c. 线程安全，多个goroutine同时访问，不需要加锁 d. channel是有类型的，一个整数的channel只能存放整数 2.channel语法 2.1 var 变量名 chan 类型 package main var ch0 chan int var ch1 chan string var ch2 chan map[string]string type stu struct{} var ch3 chan stu var ch4 chan *stu func main(){} 2.2 channel方向 ch Channel类型的定义格式如下： ChannelType = ( \"chan\" | \"chan\" \" 它包括三种类型的定义。可选的 chan T // 可以接收和发送类型为 T 的数据 chan chan 2.3 send发送（先进） send语句用来往Channel中发送数据， 如ch 。 它的定义如下: SendStmt = Channel \" 在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。 c := make(chan int) defer close(c) go func() { c send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行 往一个已经被close的channel中继续发送数据会导致run-time panic。 往nil channel中发送数据会一致被阻塞着。 2.4 receive 接受（先出） 用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。 如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。 x, ok := 如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。 3. make进行初始化 package main import (\"fmt\") var ch0 chan int =make(chan int) var ch1 chan int =make(chan int,10) func main(){ var ch2 chan string ch2 =make(chan string) var ch3 chan string ch3 =make(chan string,1) ch4 :=make(chan float32) ch5 :=make(chan float64,2) fmt.Printf(\"无缓冲 全局变量 chan ch0 : %v\\n\", ch0) fmt.Printf(\"有缓冲 全局变量 chan ch1 : %v\\n\", ch1) fmt.Printf(\"无缓冲 局部变量 chan ch2 : %v\\n\", ch2) fmt.Printf(\"有缓冲 局部变量 chan ch3 : %v\\n\", ch3) fmt.Printf(\"无缓冲 局部变量 chan ch4 : %v\\n\", ch4) fmt.Printf(\"有缓冲 局部变量 chan ch5 : %v\\n\", ch5)} 输出结果： 无缓冲 全局变量 chan ch0 :0xc420070060 有缓冲 全局变量 chan ch1 :0xc42001c0b0 无缓冲 局部变量 chan ch2 :0xc4200700c0 有缓冲 局部变量 chan ch3 :0xc420054060 无缓冲 局部变量 chan ch4 :0xc420070120 有缓冲 局部变量 chan ch5 :0xc420050070 通过缓存的使用，可以尽量避免阻塞，提供应用的性能。 容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。 如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。 可以通过内建的close方法可以关闭Channel。 你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。 Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。 无缓存的与有缓存channel有着重大差别，那就是一个是同步的 一个是非同步的。 比如 c1:=make(chan int) 无缓存 c2:=make(chan int,1) 有缓存 c1无缓存： 不仅仅是向 c1 通道放 1，而是一直要等有别的携程 4. 不同类型channel写入、读取 package main import (\"fmt\") type Stu struct { name string } func main(){ var intChan chan int //int类型 intChan =make(chan int,10) intChan 5. 判断channel 它可以用来检查Channel是否已经被关闭了。 v, ok := 6. channel 写入、读取 cat ch1.go package main import (\"fmt\") func main(){ ch :=make(chan int,11)//写入chan ch 7. close()处理chan 使用内置函数close进行关闭，chan关闭之后，for range遍历chan中已经存在的元素后结束 使用内置函数close进行关闭，chan关闭之后，没有使用for range的写法，需要使用，v, ok := $ cat ch2.go package main import \"fmt\" func main(){ var ch chan int ch =make(chan int,5) for i :=0; i 如果将close(ch)注释掉，意思是不关闭管道，那么会出现dead lock死锁 因为存入管道5个数字，然后无限取数据，会出现死锁。 $ cat ch3.go package main import \"fmt\" func main(){ var ch chan int ch =make(chan int,5) for i :=0; i 向 closed channel 发送数据引发 panic 错误，接收立即返回零值。而 nil channel， 无论收发都会被阻塞。 package main func main(){ ch :=make(chan int,1) close(ch) ch 8. range 遍历 chan $ cat ch4.go package main import \"fmt\" func main(){ var ch chan int ch =make(chan int,10) for i :=0; i 同样如果将close(ch)注释掉，意思是不关闭管道，那么会出现dead lock死锁 除用 range 外，还可用 ok-idiom 模式判断 channel 是否关闭。 $ cat ch5.go package main import \"fmt\" func main(){ var ch chan int ch =make(chan int,10) for i :=0; i 9. 内置函数len()、cap()处理chan len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小。 $ cat ch6.go package main import \"fmt\" func main(){ ch1 :=make(chan int) ch2 :=make(chan int,3) ch2 10. select处理chan select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 select语句选择一组可能的send操作和receive操作去处理。它类似switch,但是只是用来处理通讯(communication)操作。 它的case可以是send语句，也可以是receive语句，亦或者default。 receive语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。 最多允许有一个default case,它可以放在case列表的任何位置，尽管我们大部分会将它放在最后。 $ cat ch7-1.go package main import (\"fmt\") func main(){ ch1 :=make(chan int,1) ch1 $ cat ch7-2.go package main import \"fmt\" func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c 11. timeout处理chan select有很重要的一个应用就是超时处理。 因为上面我们提到，如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况。 下面这个例子我们会在2秒后往channel c1中发送一个数据，但是select设置为1秒超时,因此我们会打印出timeout 1,而不是result 1。 $ cat ch11.go package main import \"time\" import \"fmt\" func main() { c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 其实它利用的是time.After方法，它返回一个类型为 12. chan的只读和只写 12.1 只读chan的声明 var 变量名 package main var ch0 12.2 只写chan的声明 var 变量名 chan package main var ch0 chan 13. channel单向 可以将 channel 隐式转换为单向队列，只收或只发。 package main import (\"fmt\") func main(){ c :=make(chan int,3) var send chan 不能将单向 channel 转换为普通 channel。 package main func main(){ c :=make(chan int,3) var send chan 14. channel传参 channel 是第一类对象，可传参 (内部实现为指针) 或者作为结构成员。 $ cat ch8.go package main import \"fmt\" type Request struct { data []int ret chan int } func NewRequest(data ...int)*Request { return&Request{data,make(chan int,1)} } func Process(req *Request){ x :=0 for _, i := range req.data { x += i } req.ret 参考： http://www.ahadoc.com/read/Golang-Detailed-Explanation/ch2.4.4.md https://colobu.com/2016/04/14/Golang-Channels/ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_26_container.html":{"url":"Go-Base/go_26_container.html","title":"go container 容器数据类型 heap list  ring","keywords":"","body":"Go container 容器数据类型：heap、list 、ringGo container 容器数据类型：heap、list 、ring 该包实现了三个复杂的数据结构：堆，链表，环。 这个包就意味着你使用这三个数据结构的时候不需要再费心从头开始写算法了。 这里的堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。 go 的堆包只是实现了一个接口，我们看下它的定义： type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. } 回顾下 sort.Interface，它需要实现三个方法 Len() int Less(i, j int) bool Swap(i, j int) 加上堆接口定义的两个方法 Push(x interface{}) Pop() interface{} 实例1： package main import ( \"container/heap\" \"fmt\" ) type IntHeap []int //我们自定义一个堆需要实现5个接口 //Len(),Less(),Swap()这是继承自sort.Interface //Push()和Pop()是堆自已的接口 //返回长度 func (h *IntHeap) Len() int { return len(*h); } //比较大小(实现最小堆) func (h *IntHeap) Less(i, j int) bool { return (*h)[i] [root@localhost container]# go run test.go [1] [2 3] [6 5 4] 1 [2] [4 3] [6 5] 2 [3] [4 5] [6] [0] [3 5] [6 4 8] Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Base/go_27_cas.html":{"url":"Go-Base/go_27_cas.html","title":"go cas操作","keywords":"","body":"Go CAS操作Go CAS操作 go中的Cas操作与java中类似，都是借用了CPU提供的原子性指令来实现。CAS操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。下面一个例子使用CAS来实现计数器 package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var ( counter int32 //计数器 wg sync.WaitGroup //信号量 ) func main() { threadNum := 5 //1. 五个信号量 wg.Add(threadNum) //2.开启5个线程 for i := 0; i [root@localhost cas]# go run test1.go thread,4,spinnum,0 thread,0,spinnum,0 thread,1,spinnum,0 thread,2,spinnum,0 thread,3,spinnum,0 5 如上代码main线程首先创建了5个信号量，然后开启五个线程执行incCounter方法 incCounter内部执行代码2.1 使用cas操作递增counter的值， atomic.CompareAndSwapInt32具有三个参数，第一个是变量的地址，第二个是变量当前值，第三个是要修改变量为多少，该函数如果发现传递的old值等于当前变量的值，则使用第三个变量替换变量的值并返回true，否则返回false。 这里之所以使用无限循环是因为在高并发下每个线程执行CAS并不是每次都成功，失败了的线程需要重写获取变量当前的值，然后重新执行CAS操作。读者可以把线程数改为10000或者更多会发现输出thread,5329,spinnum,1其中1说明该线程尝试了两个CAS操作，第二次才成功。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Package/":{"url":"Go-Package/","title":"Go Package","keywords":"","body":"Go PackageGo Package Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 14:19:08 "},"Go-Package/go-pflag.html":{"url":"Go-Package/go-pflag.html","title":"go 库 pflag 命令行参数解析","keywords":"","body":"Go 库 pflag 命令行参数解析1. 背景2. pflag 简介3. Pflag 包 Flag 定义4. Pflag 包 FlagSet 定义5. 安装6. 方法6.1 支持多种命令行参数定义方式。6.2 使用Get获取参数的值6.3 获取非选项参数6.4 指定了选项但是没有指定选项值时的默认值6.5 弃用标志或者标志的简写6.6 保留名为 port 的标志，但是弃用它的简写形式6.7 隐藏标志7. 实例7.1 练习17.2 练习27.3 练习3. flag.Lookup7.4 flag与pflag混用Go 库 pflag 命令行参数解析 1. 背景 Go 服务开发中，经常需要给开发的组件加上各种启动参数来配置服务进程，影响服务的行为。像 kube-apiserver 就有多达 200 多个启动参数，而且这些参数的类型各不相同（例如：string、int、ip 类型等），使用方式也不相同（例如：需要支持--长选项，-短选项等），所以我们需要一个强大的命令行参数解析工具。 虽然 Go 源码中提供了一个标准库 Flag 包，用来对命令行参数进行解析，但在大型项目中应用更广泛的是另外一个包：Pflag。Pflag 提供了很多强大的特性，非常适合用来构建大型项目，一些耳熟能详的开源项目都是用 Pflag 来进行命令行参数解析的，例如：Kubernetes、Istio、Helm、Docker、Etcd 等。接下来，我们就来介绍下如何使用 Pflag。Pflag 主要是通过创建 Flag 和 FlagSet 来使用的。我们先来看下 Flag。 2. pflag 简介 pflag是Go的flag包的直接替代，实现了POSIX / GNU样式的--flags。pflag是Go的本机标志包的直接替代。如果您在名称“ flag”下导入pflag，则所有代码应继续运行且无需更改。 github：https://github.com/spf13/pflag 源码包：https://godoc.org/github.com/spf13/pflag#Args 默认标志位：-- --flag // boolean flags, or flags with no option default values --flag x // only on flags without a default value --flag=x 3. Pflag 包 Flag 定义 Pflag 可以对命令行参数进行处理，一个命令行参数在 Pflag 包中会解析为一个 Flag 类型的变量。Flag 是一个结构体，定义如下： type Flag struct { Name string // flag长选项的名称 Shorthand string // flag短选项的名称，一个缩写的字符 Usage string // flag的使用文本 Value Value // flag的值 DefValue string // flag的默认值 Changed bool // 记录flag的值是否有被设置过 NoOptDefVal string // 当flag出现在命令行，但是没有指定选项值时的默认值 Deprecated string // 记录该flag是否被放弃 Hidden bool // 如果值为true，则从help/usage输出信息中隐藏该flag ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息 Annotations map[string][]string // 给flag设置注解 } Flag 的值是一个 Value 类型的接口，Value 定义如下： type Value interface { String() string // 将flag类型的值转换为string类型的值，并返回string的内容 Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错 Type() string // 返回flag的类型，例如：string、int、ip等 } 通过将 Flag 的值抽象成一个 interface 接口，我们就可以自定义 Flag 的类型了。只要实现了 Value 接口的结构体，就是一个新类型。 4. Pflag 包 FlagSet 定义 Pflag 除了支持单个的 Flag 之外，还支持 FlagSet。FlagSet 是一些预先定义好的 Flag 的集合，几乎所有的 Pflag 操作，都需要借助 FlagSet 提供的方法来完成。在实际开发中，我们可以使用两种方法来获取并使用 FlagSet： 方法一，调用 NewFlagSet 创建一个 FlagSet。 方法二，使用 Pflag 包定义的全局 FlagSet：CommandLine。实际上 CommandLine 也是由 NewFlagSet 函数创建的。 先来看下第一种方法，自定义 FlagSet。下面是一个自定义 FlagSet 的示例： var version bool flagSet := pflag.NewFlagSet(\"test\", pflag.ContinueOnError) flagSet.BoolVar(&version, \"version\", true, \"Print version information and quit.\") 我们可以通过定义一个新的 FlagSet 来定义命令及其子命令的 Flag。再来看下第二种方法，使用全局 FlagSet。下面是一个使用全局 FlagSet 的示例： import ( \"github.com/spf13/pflag\" ) pflag.BoolVarP(&version, \"version\", \"v\", true, \"Print version information and quit.\") 这其中，pflag.BoolVarP 函数定义如下： func BoolVarP(p *bool, name, shorthand string, value bool, usage string) { flag := CommandLine.VarPF(newBoolValue(value, p), name, shorthand, usage) flag.NoOptDefVal = \"true\" } 可以看到 pflag.BoolVarP 最终调用了 CommandLine，CommandLine 是一个包级别的变量，定义为： // CommandLine is the default set of command-line flags, parsed from os.Args. var CommandLine = NewFlagSet(os.Args[0], ExitOnError) 5. 安装 go get github.com/spf13/pflag 6. 方法 6.1 支持多种命令行参数定义方式。 支持长选项、默认值和使用文本，并将标志的值存储在指针中。 var name = pflag.String(\"name\", \"colin\", \"Input Your Name\") 支持长选项、短选项、默认值和使用文本，并将标志的值存储在指针中。 var name = pflag.StringP(\"name\", \"n\", \"colin\", \"Input Your Name\") 支持长选项、默认值和使用文本，并将标志的值绑定到变量。 var name string pflag.StringVar(&name, \"name\", \"colin\", \"Input Your Name\") 支持长选项、短选项、默认值和使用文本，并将标志的值绑定到变量。 var name string pflag.StringVarP(&name, \"name\", \"n\",\"colin\", \"Input Your Name\") 上面的函数命名是有规则的： 函数名带Var说明是将标志的值绑定到变量，否则是将标志的值存储在指针中。 函数名带P说明支持短选项，否则不支持短选项。 6.2 使用Get获取参数的值 可以使用Get来获取标志的值，代表 Pflag 所支持的类型。例如：有一个 pflag.FlagSet，带有一个名为 flagname 的 int 类型的标志，可以使用GetInt()来获取 int 值。需要注意 flagname 必须存在且必须是 int，例如： i, err := flagset.GetInt(\"flagname\") 6.3 获取非选项参数 package main import ( \"fmt\" \"github.com/spf13/pflag\" ) var ( flagvar = pflag.Int(\"flagname\", 1234, \"help message for flagname\") ) func main() { pflag.Parse() fmt.Printf(\"argument number is: %v\\n\", pflag.NArg()) fmt.Printf(\"argument list is: %v\\n\", pflag.Args()) fmt.Printf(\"the first argument is: %v\\n\", pflag.Arg(0)) } 执行上述代码，输出如下： $ go run example1.go arg1 arg2 argument number is: 2 argument list is: [arg1 arg2] the first argument is: arg1 在定义完标志之后，可以调用pflag.Parse()来解析定义的标志。解析后，可通过pflag.Args()返回所有的非选项参数，通过pflag.Arg(i)返回第 i 个非选项参数。参数下标 0 到 pflag.NArg() - 1。 6.4 指定了选项但是没有指定选项值时的默认值 创建一个 Flag 后，可以为这个 Flag 设置pflag.NoOptDefVal。如果一个 Flag 具有 NoOptDefVal，并且该 Flag 在命令行上没有设置这个 Flag 的值，则该标志将设置为 NoOptDefVal 指定的值。例如： var ip = pflag.IntP(\"flagname\", \"f\", 1234, \"help message\") pflag.Lookup(\"flagname\").NoOptDefVal = \"4321\" 上面的代码会产生结果，具体你可以参照下表 6.5 弃用标志或者标志的简写 Pflag 可以弃用标志或者标志的简写。弃用的标志或标志简写在帮助文本中会被隐藏，并在使用不推荐的标志或简写时打印正确的用法提示。例如，弃用名为 logmode 的标志，并告知用户应该使用哪个标志代替： // deprecate a flag by specifying its name and a usage message pflag.CommandLine.MarkDeprecated(\"logmode\", \"please use --log-mode instead\") 这样隐藏了帮助文本中的 logmode，并且当使用 logmode 时，打印了Flag --logmode has been deprecated, please use --log-mode instead。 6.6 保留名为 port 的标志，但是弃用它的简写形式 pflag.IntVarP(&port, \"port\", \"P\", 3306, \"MySQL service host port.\") // deprecate a flag shorthand by specifying its flag name and a usage message pflag.CommandLine.MarkShorthandDeprecated(\"port\", \"please use --port only\") 这样隐藏了帮助文本中的简写 P，并且当使用简写 P 时，打印了Flag shorthand -P has been deprecated, please use --port only。usage message 在此处必不可少，并且不应为空。 6.7 隐藏标志 可以将 Flag 标记为隐藏的，这意味着它仍将正常运行，但不会显示在 usage/help 文本中。例如：隐藏名为 secretFlag 的标志，只在内部使用，并且不希望它显示在帮助文本或者使用文本中。代码如下： // hide a flag by specifying its name pflag.CommandLine.MarkHidden(\"secretFlag\") 7. 实例 7.1 练习1 package main import ( flag \"github.com/spf13/pflag\" //替换原生的flag，并兼容 \"fmt\" ) var flagvar1 int var flagvar2 bool func init() { flag.IntVar(&flagvar1, \"varname1\", 1, \"help message for flagname\") flag.BoolVarP(&flagvar2, \"boolname1\", \"b\", true, \"help message\") } func main() { var ip1 *int = flag.Int(\"flagname1\", 1, \"help message for flagname\") var ip2 = flag.IntP(\"flagname2\", \"f\", 2, \"help message\") flag.Parse() fmt.Println(\"ip1 has value \", *ip1) fmt.Println(\"ip2 has value \", *ip2) fmt.Println(\"flagvar1 has value \", flagvar1) fmt.Println(\"flagvar2 has value \", flagvar2) } $ go build fplag1.go /pflag1 -h Usage of ./pflag1: -b, --boolname1 help message (default true) --flagname1 int help message for flagname (default 1) -f, --flagname2 int help message (default 2) --varname1 int help message for flagname (default 1) pflag: help requested 7.2 练习2 package main import ( \"github.com/spf13/pflag\" \"net\" \"fmt\" \"time\" ) func pflagDefine() { //64位整数，不带单标志位的 var pflagint64 *int64 = pflag.Int64(\"number1\", 1234, \"this is int 64, without single flag\") //64位整数，带单标志位的 var pflagint64p *int64 = pflag.Int64P(\"number2\", \"n\", 2345, \"this is int 64, without single flag\") //这种可以把变量的定义和变量取值分开，适合于struct，全局变量等地方 var pflagint64var int64 pflag.Int64Var(&pflagint64var, \"number3\", 1234, \"this is int64var\") //上面那一种的增加短标志位版 var pflagint64varp int64 pflag.Int64VarP(&pflagint64varp,\"number4\", \"m\", 1234, \"this is int64varp\") //slice版本,其实是上面的增强版，但是支持多个参数，也就是导成一个slice var pflagint64slice *[]int64 = pflag.Int64Slice(\"number5\", []int64{1234, 3456}, \"this is int64 slice\") //bool版本 var pflagbool *bool = pflag.Bool(\"bool\", true, \"this is bool\") //bytes版本 var pflagbyte *[]byte = pflag.BytesBase64(\"byte64\", []byte(\"ea\"), \"this is byte base64\") //count版本 var pflagcount *int= pflag.Count(\"count\", \"this is count\") //duration版本 var pflagduration *time.Duration = pflag.Duration(\"duration\", 10* time.Second, \"this is duration\") //float版本 var pflagfloat *float64 = pflag.Float64(\"float64\", 123.345, \"this is florat64\") //IP版本 var pflagip *net.IP = pflag.IP(\"ip1\", net.IPv4(192, 168, 1, 1), \"this is ip, without single flag\") //mask版本 var pflagmask *net.IPMask= pflag.IPMask(\"mask\", net.IPv4Mask(255,255,255,128),\"this is net mask\") //string版本 var pflagstring *string= pflag.String(\"string\", \"teststring\", \"this is string\") //uint版本 var pflaguint *uint64 = pflag.Uint64(\"uint64\", 12345, \"this is uint64\") pflag.Parse() fmt.Println(\"number1 int64 is \", *pflagint64) fmt.Println(\"number2 int64 is \", *pflagint64p) fmt.Println(\"number3 int64var is \", pflagint64var) fmt.Println(\"number4 int64varp is\", pflagint64varp) fmt.Println(\"number5 int64slice is\", *pflagint64slice) fmt.Println(\"bool is \", *pflagbool) fmt.Println(\"byte64 is \", *pflagbyte) fmt.Println(\"count is \", *pflagcount) fmt.Println(\"duration is \", *pflagduration) fmt.Println(\"float is \", *pflagfloat) fmt.Println(\"ip1 net.ip is \", *pflagip) fmt.Println(\"mask is %s\", *pflagmask) fmt.Println(\"string is \", *pflagstring) fmt.Println(\"uint64 is \", *pflaguint) } func main() { pflagDefine() } $ go build pflag2.go $ ./pflag2 -h Usage of ./pflag1: --bool this is bool (default true) --byte64 bytesBase64 this is byte base64 (default ZWE=) --count count this is count --duration duration this is duration (default 10s) --float64 float this is florat64 (default 123.345) --ip1 ip this is ip, without single flag (default --mask ipMask this is net mask (default ffffff80) --number1 int this is int 64, without single flag (defa -n, --number2 int this is int 64, without single flag (defa --number3 int this is int64var (default 1234) -m, --number4 int this is int64varp (default 1234) --number5 int64Slice this is int64 slice (default [1234,3456]) --string string this is string (default \"teststring\") --uint64 uint this is uint64 (default 12345) pflag: help requested 7.3 练习3. flag.Lookup flag包中提供了一种类似上述的”配置中心”的机制，但这种机制不需要我们显示注入“flag vars”了，我们只需按照flag提供的方法在其他package中读取对应flag变量的值即可。 $tree flaglookup flaglookup ├── etcd │ └── etcd.go └── main.go // flag-demo/flaglookup/main.go package main import ( \"flag\" \"fmt\" \"time\" \"./etcd\" ) var ( endpoints string user string password string ) func init() { flag.StringVar(&endpoints, \"endpoints\", \"127.0.0.1:2379\", \"comma-separated list of etcdv3 endpoints\") flag.StringVar(&user, \"user\", \"\", \"etcdv3 client user\") flag.StringVar(&password, \"password\", \"\", \"etcdv3 client password\") } func usage() { fmt.Println(\"flagdemo-app is a daemon application which provides xxx service.\\n\") fmt.Println(\"Usage of flagdemo-app:\\n\") fmt.Println(\"\\t flagdemo-app [options]\\n\") fmt.Println(\"The options are:\\n\") flag.PrintDefaults() } func main() { flag.Usage = usage flag.Parse() go etcd.EtcdProxy() time.Sleep(5 * time.Second) } // flag-demo/flaglookup/etcd/etcd.go package etcd import ( \"flag\" \"fmt\" ) func EtcdProxy() { endpoints := flag.Lookup(\"endpoints\").Value.(flag.Getter).Get().(string) user := flag.Lookup(\"user\").Value.(flag.Getter).Get().(string) password := flag.Lookup(\"password\").Value.(flag.Getter).Get().(string) fmt.Println(endpoints, user, password) } [root@localhost flaglookup]# go run main.go -endpoints 192.168.10.69:2379,10.10.12.36:2378 -user tonybai -password xyz123 192.168.10.69:2379,10.10.12.36:2378 tonybai xyz123 7.4 flag与pflag混用 混用flag及pflag时，注意使用的方法 import ( goflag \"flag\" flag \"github.com/spf13/pflag\" ) var ip *int = flag.Int(\"flagname\", 1234, \"help message for flagname\") func main() { flag.CommandLine.AddGoFlagSet(goflag.CommandLine) flag.Parse() } 参考： https://www.cnblogs.com/sparkdev/p/10833186.html 黑魔法：pflag.lookup Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Package/go-viper.html":{"url":"Go-Package/go-viper.html","title":"go 库 viper 配置解析神器","keywords":"","body":"Go 库 viper 配置解析神器1. 简介2. 安装3. 建立默认值4. 读取配置文件5. 获取 key/value 方法5.1 Get() 方法5.2 IsSet()、GetStringMap()、GetStringMap() 方法6. 命令行选项7. 访问嵌套的键8. 写入配置文件9. 监控并重新读取配置文件10. 从io.Reader中读取11. Unmarshal12. 环境变量13. 远程Key/Value存储支持13.1 远程Key/Value存储示例-未加密13.2 远程Key/Value存储示例-加密13.3 监控etcd中的更改-未加密Go 库 viper 配置解析神器 1. 简介 几乎所有的后端服务，都需要一些配置项来配置我们的服务，一些小型的项目，配置不是很多，可以选择只通过命令行参数来传递配置。但是大型项目配置很多，通过命令行参数传递就变得很麻烦，不好维护。标准的解决方案是将这些配置信息保存在配置文件中，由程序启动时加载和解析。Go 生态中有很多包可以加载并解析配置文件，目前最受欢迎的是 Viper 包。Viper 是 Go 应用程序现代化的、完整的解决方案，能够处理不同格式的配置文件，让我们在构建现代应用程序时，不必担心配置文件格式。Viper 也能够满足我们对应用配置的各种需求。 Viper 可以从不同的位置读取配置，不同位置的配置具有不同的优先级，高优先级的配置会覆盖低优先级相同的配置，按优先级从高到低排列如下： 通过 viper.Set 函数显示设置的配置 命令行参数 环境变量 配置文件 Key/Value 存储 默认值 Viper 有很多功能，最重要的两类功能是读入配置和读取配置，Viper 提供不同的方式来实现这两类功能。 2. 安装 go get github.com/spf13/viper 3. 建立默认值 一个好的配置系统应该支持默认值。键不需要默认值，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置键，则默认值非常有用。 代码 viper1.go package main import ( \"fmt\" \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config1\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") viper.SetDefault(\"ContentDir\", \"content\") viper.SetDefault(\"LayoutDir\", \"layouts\") viper.SetDefault(\"Taxonomies\", map[string]string{\"tag\": \"tags\", \"category\": \"categories\"}) err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(\"ContentDir: \", viper.GetString(\"ContentDir\")) fmt.Println(\"LayoutDir: \", viper.GetString(\"LayoutDir\")) fmt.Println(\"Taxonomies: \", viper.Get(\"Taxonomies\")) } 执行： $ go run viper4.go ContentDir: content LayoutDir: layouts Taxonomies: map[category:categories tag:tags] 4. 读取配置文件 Viper需要最少知道在哪里查找配置文件的配置。Viper支持JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件。Viper可以搜索多个路径，但目前单个Viper实例只支持单个配置文件。Viper不默认任何配置搜索路径，将默认决策留给应用程序。 下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。 viper.SetConfigFile(\"./config.yaml\") // 指定配置文件路径 viper.SetConfigName(\"config\") // 配置文件名称(无扩展名) viper.SetConfigType(\"yaml\") // 如果配置文件的名称中没有扩展名，则需要配置此项 viper.AddConfigPath(\"/etc/appname/\") // 查找配置文件所在的路径 viper.AddConfigPath(\"$HOME/.appname\") // 多次调用以添加多个搜索路径 viper.AddConfigPath(\".\") // 还可以在工作目录中查找配置 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { // 处理读取配置文件的错误 panic(fmt.Errorf(\"Fatal error config file: %s \\n\", err)) } 在加载配置文件出错时，你可以像下面这样处理找不到配置文件的特定情况： if err := viper.ReadInConfig(); err != nil { if _, ok := err.(viper.ConfigFileNotFoundError); ok { // 配置文件未找到错误；如果需要可以忽略 } else { // 配置文件被找到，但产生了另外的错误 } } // 配置文件找到并成功解析 5. 获取 key/value 方法 Viper 提供了如下方法来读取配置： Get(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool AllSettings() : map[string]interface{} 每一个 Get 方法在找不到值的时候都会返回零值。为了检查给定的键是否存在，可以使用 IsSet() 方法。可以是 Viper 支持的类型，首字母大写：Bool、Float64、Int、IntSlice、String、StringMap、StringMapString、StringSlice、Time、Duration。例如：GetInt()。 5.1 Get() 方法 配置文件：config.toml app_name = \"awesome web\" # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = \"DEBUG\" [mysql] ip = \"127.0.0.1\" port = 3306 user = \"dj\" password = 123456 database = \"awesome\" [redis] ip = \"127.0.0.1\" port = 7381 代码 viper1.go： package main import ( \"fmt\" \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") viper.SetDefault(\"redis.port\", 6381) err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(viper.Get(\"app_name\")) fmt.Println(viper.Get(\"log_level\")) fmt.Println(\"mysql ip: \", viper.Get(\"mysql.ip\")) fmt.Println(\"mysql port: \", viper.Get(\"mysql.port\")) fmt.Println(\"mysql user: \", viper.Get(\"mysql.user\")) fmt.Println(\"mysql password: \", viper.Get(\"mysql.password\")) fmt.Println(\"mysql database: \", viper.Get(\"mysql.database\")) fmt.Println(\"redis ip: \", viper.Get(\"redis.ip\")) fmt.Println(\"redis port: \", viper.Get(\"redis.port\")) } 设置文件名（SetConfigName）、配置类型（SetConfigType）和搜索路径（AddConfigPath），然后调用ReadInConfig。 viper会自动根据类型来读取配置。使用时调用viper.Get方法获取键值。 执行： $ go run viper1.go awesome web DEBUG mysql ip: 127.0.0.1 mysql port: 3306 mysql user: dj mysql password: 123456 mysql database: awesome redis ip: 127.0.0.1 redis port: 7381 有几点需要注意： 设置文件名时不要带后缀； 搜索路径可以设置多个，viper 会根据设置顺序依次查找； viper 获取值时使用section.key的形式，即传入嵌套的键名； 默认值可以调用viper.SetDefault设置。 5.2 IsSet()、GetStringMap()、GetStringMap() 方法 viper 提供了多种形式的读取方法。在上面的例子中，我们看到了Get方法的用法。Get方法返回一个interface{}的值，使用有所不便。 GetType系列方法可以返回指定类型的值。其中，Type 可以为Bool、Float64、Int、String、Time、Duration、IntSlice、StringSlice。但是请注意，如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值。 如果要判断某个键是否存在，使用IsSet方法。另外，GetStringMap和GetStringMapString直接以 map 返回某个键下面所有的键值对，前者返回map[string]interface{}，后者返回map[string]string。AllSettings以map[string]interface{}返回所有设置。 配置文件config.toml app_name = \"awesome web\" # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = \"DEBUG\" [server] protocols = [\"http\", \"https\", \"port\"] ports = [10000, 10001, 10002] timeout = '3s' [mysql] ip = \"127.0.0.1\" port = 3306 user = \"dj\" password = 123456 database = \"awesome\" [redis] ip = \"127.0.0.1\" port = 7381 viper2.go 文件 package main import ( \"fmt\" \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(\"protocols: \", viper.GetStringSlice(\"server.protocols\")) fmt.Println(\"ports: \", viper.GetIntSlice(\"server.ports\")) fmt.Println(\"timeout: \", viper.GetDuration(\"server.timeout\")) fmt.Println(\"mysql ip: \", viper.GetString(\"mysql.ip\")) fmt.Println(\"mysql port: \", viper.GetInt(\"mysql.port\")) if viper.IsSet(\"redis.port\") { fmt.Println(\"redis.port is set\") } else { fmt.Println(\"redis.port is not set\") } fmt.Println(\"mysql settings: \", viper.GetStringMap(\"mysql\")) fmt.Println(\"redis settings: \", viper.GetStringMap(\"redis\")) fmt.Println(\"all settings: \", viper.AllSettings()) } 如果将配置中的redis.port注释掉，将输出redis.port is not set。 上面的示例中还演示了如何使用time.Duration类型，只要是time.ParseDuration接受的格式都可以，例如3s、2min、1min30s等。 执行： $ go run viper2.go protocols: [http https port] ports: [10000 10001 10002] timeout: 3s mysql ip: 127.0.0.1 mysql port: 3306 redis.port is set mysql settings: map[database:awesome ip:127.0.0.1 password:123456 port:3306 user:dj] redis settings: map[ip:127.0.0.1 port:7381] all settings: map[app_name:awesome web log_level:DEBUG mysql:map[database:awesome ip:127.0.0.1 password:123456 port:3306 user:dj] redis:map[ip:127.0.0.1 port:7381] server:map[ports:[10000 10001 10002] protocols:[http https port] timeout:3s]] 6. 命令行选项 如果一个键没有通过viper.Set显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在init方法中定义选项，并且调用viper.BindPFlags绑定选项到配置中： 代码 viper.go package main import ( \"fmt\" \"log\" \"github.com/spf13/pflag\" \"github.com/spf13/viper\" ) func init() { pflag.Int(\"redis.port\", 8381, \"Redis port to connect\") // 绑定命令行 viper.BindPFlags(pflag.CommandLine) } func main() { pflag.Parse() viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(viper.Get(\"app_name\")) fmt.Println(viper.Get(\"log_level\")) fmt.Println(\"mysql ip: \", viper.Get(\"mysql.ip\")) fmt.Println(\"mysql port: \", viper.Get(\"mysql.port\")) fmt.Println(\"mysql user: \", viper.Get(\"mysql.user\")) fmt.Println(\"mysql password: \", viper.Get(\"mysql.password\")) fmt.Println(\"mysql database: \", viper.Get(\"mysql.database\")) fmt.Println(\"redis ip: \", viper.Get(\"redis.ip\")) fmt.Println(\"redis port: \", viper.Get(\"redis.port\")) } 执行： $ go run viper8.go awesome web DEBUG mysql ip: 127.0.0.1 mysql port: 3306 mysql user: root mysql password: 123456 mysql database: awesome redis ip: 127.0.0.1 redis port: 6381 $ go run viper8.go --redis.port 10831 awesome web DEBUG mysql ip: 127.0.0.1 mysql port: 3306 mysql user: root mysql password: 123456 mysql database: awesome redis ip: 127.0.0.1 redis port: 10831 7. 访问嵌套的键 例如，加载下面的 JSON 文件 config.json： { \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } viper3.go文件 package main import ( \"fmt\" \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"json\") viper.AddConfigPath(\".\") err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(\"host: \", viper.GetString(\"datastore.metric.host\")) } 执行： $ go run viper3.go host: 127.0.0.1 这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件 > 命令行标志位 > 环境变量 > 远程Key/Value存储 > 默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。) 例如，在给定此配置文件的情况下，datastore.metric.host和datastore.metric.port均已定义（并且可以被覆盖）。如果另外在默认值中定义了datastore.metric.protocol，Viper也会找到它。 然而，如果datastore.metric被直接赋值覆盖（被flag，环境变量，set()方法等等…），那么datastore.metric的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了。 最后，如果存在与分隔的键路径匹配的键，则返回其值。例如： { \"datastore.metric.host\": \"0.0.0.0\", \"host\": { \"address\": \"localhost\", \"port\": 5799 }, \"datastore\": { \"metric\": { \"host\": \"127.0.0.1\", \"port\": 3099 }, \"warehouse\": { \"host\": \"198.0.0.1\", \"port\": 2112 } } } GetString(\"datastore.metric.host\") // 返回 \"0.0.0.0\" 8. 写入配置文件 从配置文件中读取配置文件是有用的，但是有时你想要存储在运行时所做的所有修改。为此，可以使用下面一组命令，每个命令都有自己的用途: WriteConfig - 将当前的viper配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。 SafeWriteConfig - 将当前的viper配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。 WriteConfigAs - 将当前的viper配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。 SafeWriteConfigAs - 将当前的viper配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。 根据经验，标记为safe的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断。 viper.WriteConfig() // 将当前配置写入“viper.AddConfigPath()”和“viper.SetConfigName”设置的预定义路径 viper.SafeWriteConfig() viper.WriteConfigAs(\"/path/to/my/.config\") viper.SafeWriteConfigAs(\"/path/to/my/.config\") // 因为该配置文件写入过，所以会报错 viper.SafeWriteConfigAs(\"/path/to/my/.other_config\") 代码： package main import ( \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") viper.Set(\"app_name\", \"awesome web\") viper.Set(\"log_level\", \"DEBUG\") viper.Set(\"mysql.ip\", \"127.0.0.1\") viper.Set(\"mysql.port\", 3306) viper.Set(\"mysql.user\", \"root\") viper.Set(\"mysql.password\", \"123456\") viper.Set(\"mysql.database\", \"awesome\") viper.Set(\"redis.ip\", \"127.0.0.1\") viper.Set(\"redis.port\", 6381) err := viper.SafeWriteConfig() if err != nil { log.Fatal(\"write config failed: \", err) } } 执行： $ go run viper5.go $ cat config.toml app_name = 'awesome web' log_level = 'DEBUG' [mysql] database = 'awesome' ip = '127.0.0.1' password = '123456' port = 3306 user = 'root' [redis] ip = '127.0.0.1' port = 6381 9. 监控并重新读取配置文件 Viper支持在运行时实时读取配置文件的功能。 需要重新启动服务器以使配置生效的日子已经一去不复返了，viper驱动的应用程序可以在运行时读取配置文件的更新，而不会错过任何消息。 只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。 package main import ( \"fmt\" \"log\" \"time\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } viper.WatchConfig() fmt.Println(\"redis port before sleep: \", viper.Get(\"redis.port\")) time.Sleep(time.Second * 10) fmt.Println(\"redis port after sleep: \", viper.Get(\"redis.port\")) } 只需要调用viper.WatchConfig，viper 会自动监听配置修改。如果有修改，重新加载的配置。 上面程序中，我们先打印redis.port的值，然后Sleep 10s。在这期间修改配置中redis.port的值，Sleep结束后再次打印。 发现打印出修改后的值： redis port before sleep: 7381 redis port after sleep: 73810 另外，还可以为配置修改增加一个回调： viper.OnConfigChange(func(e fsnotify.Event) { fmt.Printf(\"Config file:%s Op:%s\\n\", e.Name, e.Op) }) 这样文件修改时会执行这个回调。 viper 使用fsnotify这个库来实现监听文件修改的功能。 10. 从io.Reader中读取 viper 支持从io.Reader中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。 package main import ( \"bytes\" \"fmt\" \"log\" \"github.com/spf13/viper\" ) func main() { viper.SetConfigType(\"toml\") tomlConfig := []byte(` app_name = \"awesome web\" # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = \"DEBUG\" [mysql] ip = \"127.0.0.1\" port = 3306 user = \"dj\" password = 123456 database = \"awesome\" [redis] ip = \"127.0.0.1\" port = 7381 `) err := viper.ReadConfig(bytes.NewBuffer(tomlConfig)) if err != nil { log.Fatal(\"read config failed: %v\", err) } fmt.Println(\"redis port: \", viper.GetInt(\"redis.port\")) } 11. Unmarshal viper 支持将配置Unmarshal到一个结构体中，为结构体中的对应字段赋值。 package main import ( \"fmt\" \"log\" \"github.com/spf13/viper\" ) type Config struct { AppName string LogLevel string MySQL MySQLConfig Redis RedisConfig } type MySQLConfig struct { IP string Port int User string Password string Database string } type RedisConfig struct { IP string Port int } func main() { viper.SetConfigName(\"config\") viper.SetConfigType(\"toml\") viper.AddConfigPath(\".\") err := viper.ReadInConfig() if err != nil { log.Fatal(\"read config failed: %v\", err) } var c Config viper.Unmarshal(&c) fmt.Println(c.MySQL) } 执行： $ go run viper7.go {127.0.0.1 3306 root 123456 awesome} 12. 环境变量 如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。 在init方法中调用AutomaticEnv方法绑定全部环境变量： func init() { // 绑定环境变量 viper.AutomaticEnv() } 为了验证是否绑定成功，通过 系统 -> 高级设置 -> 新建 创建一个名为redis.port的环境变量，值为 10381。 运行程序，输出的redis.port值为 10381，并且输出中有 GOPATH 信息。 package main import ( \"fmt\" \"github.com/spf13/viper\" ) func init() { // 绑定环境变量 viper.BindEnv(\"redis.port\") viper.BindEnv(\"go.path\", \"GOPATH\") } func main() { // 省略部分代码 fmt.Println(\"GOPATH: \", viper.Get(\"go.path\")) fmt.Println(\"redis.port: \", viper.Get(\"redis.port\")) } 执行： $ go run viper9.go GOPATH: D:\\goprojects redis.port: 10381 用BindEnv方法，如果只传入一个参数，则这个参数既表示键名，又表示环境变量名。如果传入两个参数，则第一个参数表示键名，第二个参数表示环境变量名。还可以通过viper.SetEnvPrefix方法设置环境变量前缀，这样一来，通过AutomaticEnv和一个参数的BindEnv绑定的环境变量，在使用Get的时候，viper 会自动加上这个前缀再从环境变量中查找。如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名gopath也能读取环境变量GOPATH的值。 13. 远程Key/Value存储支持 在Viper中启用远程支持，需要在代码中匿名导入viper/remote这个包。 import _ \"github.com/spf13/viper/remote\" Viper将读取从Key/Value存储（例如etcd或Consul）中的路径检索到的配置字符串（如JSON、TOML、YAML、HCL、envfile和Java properties格式）。这些值的优先级高于默认值，但是会被从磁盘、flag或环境变量检索到的配置值覆盖。（译注：也就是说Viper加载配置值的优先级为：磁盘上的配置文件>命令行标志位>环境变量>远程Key/Value存储>默认值。） Viper使用crypt从K/V存储中检索配置，这意味着如果你有正确的gpg密匙，你可以将配置值加密存储并自动解密。加密是可选的。 你可以将远程配置与本地配置结合使用，也可以独立使用。 crypt有一个命令行助手，你可以使用它将配置放入K/V存储中。crypt默认使用在http://127.0.0.1:4001的etcd。 $ go get github.com/bketelsen/crypt/bin/crypt $ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json 确认值已经设置： $ crypt get -plaintext /config/hugo.json 有关如何设置加密值或如何使用Consul的示例，请参见crypt文档。 13.1 远程Key/Value存储示例-未加密 etcd viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/hugo.json\") viper.SetConfigType(\"json\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() Consul 你需要 Consul Key/Value存储中设置一个Key保存包含所需配置的JSON值。例如，创建一个key MY_CONSUL_KEY将下面的值存入Consul key/value 存储： { \"port\": 8080, \"hostname\": \"liwenzhou.com\" } viper.AddRemoteProvider(\"consul\", \"localhost:8500\", \"MY_CONSUL_KEY\") viper.SetConfigType(\"json\") // 需要显示设置成json err := viper.ReadRemoteConfig() fmt.Println(viper.Get(\"port\")) // 8080 fmt.Println(viper.Get(\"hostname\")) // liwenzhou.com Firestore viper.AddRemoteProvider(\"firestore\", \"google-cloud-project-id\", \"collection/document\") viper.SetConfigType(\"json\") // 配置的格式: \"json\", \"toml\", \"yaml\", \"yml\" err := viper.ReadRemoteConfig() 当然，你也可以使用SecureRemoteProvider 13.2 远程Key/Value存储示例-加密 viper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\") viper.SetConfigType(\"json\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" err := viper.ReadRemoteConfig() 13.3 监控etcd中的更改-未加密 // 或者你可以创建一个新的viper实例 var runtime_viper = viper.New() runtime_viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\", \"/config/hugo.yml\") runtime_viper.SetConfigType(\"yaml\") // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\" // 第一次从远程读取配置 err := runtime_viper.ReadRemoteConfig() // 反序列化 runtime_viper.Unmarshal(&runtime_conf) // 开启一个单独的goroutine一直监控远端的变更 go func(){ for { time.Sleep(time.Second * 5) // 每次请求后延迟一下 // 目前只测试了etcd支持 err := runtime_viper.WatchRemoteConfig() if err != nil { log.Errorf(\"unable to read remote config: %v\", err) continue } // 将新配置反序列化到我们运行时的配置结构体中。你还可以借助channel实现一个通知系统更改的信号 runtime_viper.Unmarshal(&runtime_conf) } }() 参考： 李文周的博客：Go语言配置管理神器——Viper中文教程 Go 每日一库之 viper go 应用构建三剑客：Pflag、Viper、Cobra 核心功能介绍 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 13:23:35 "},"Go-Package/go-fmt.html":{"url":"Go-Package/go-fmt.html","title":"go 包 fmt 打印输出","keywords":"","body":"Go 包 fmt 打印输出1. 格式化输出函数1.1 通用1.2 布尔值1.3 整数1.4 浮点数与复数的两个组分1.5 字符串和 []byte1.6 指针1.7 其他2. 实例Go 包 fmt 打印输出 1. 格式化输出函数 func Print(a ...interface{}) (n int, err error) Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格，返回写入的字节数和遇到的任何错误。 func Printf(format string, a ...interface{}) (n int, err error) Printf根据format参数生成格式化的字符串并写入标准输出，返回写入的字节数和遇到的任何错误。 func Println(a ...interface{}) (n int, err error) Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符，返回写入的字节数和遇到的任何错误。 区别： Println :可以打印出字符串，和变量 Printf : 只可以打印出格式化的字符串,可以输出字符串类型的变量，不可以输出整形变量和整形 1.1 通用 %v 相应值的默认格式 Printf(\"%v\",person ) {zhangsan} %+v 类似%v，但输出结构体时会添加字段名式 Printf(\"%+v\",person ) {Name:zhangsan} %#v 相应值的Go语法表示 Printf(\"#v\",person ) main.Person={zhangsan} %T 相应值的类型的Go语法表示 Printf(\"%T\",person ) main.Person %% 字面上的百分号，并非值的占位符 Printf(\"%%\") % 1.2 布尔值 %t 单词true或false Printf(\"%t\",true) true 1.3 整数 %b 二进制表示 Printf(\"%b\",5) 101 %c 该值对应的unicode码值 Printf(\"%c\",0x4E2d) 中 %d 十进制表示 Printf(\"%d\",0x12) 18 %o 八进制表示 Printf(\"%o\",10) 12 %q 单引号围绕的字符字面值，由Go语法安全的转译 Printf(\"%q\",0x4E2d) '中' %x 十六进制表示，字母形式为小写a-f Printf(\"%x\",13) d %X 十六进制表示，字母形式为大写A-F Printf(\"%X\",13) D %U 表示为Unicode格式：U+1234，等价于\"U+%04X\" Printf(\"%U\",0x4E2d) U+4E2D 1.4 浮点数与复数的两个组分 %b 无小数部分、指数为二的幂的科学计数法，与strconv.FormatFloat的'b'转换格式一致。 Printf(\"%b\",10.20) 5742089524897382p-49 %e 科学计数法，如-1234.456e+78 Printf(\"%e\",10.20) 1.020000e+01 %E 科学计数法，如-1234.456E+78 Printf(\"%E\",10.20) 1.020000E+01 %f 有小数部分但无指数部分，如123.456 Printf(\"%f\",10.20) 10.200000 %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） Printf(\"%g\",10.20) 10.2 %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） Printf(\"%G\",10.20) (10.2+2i) 1.5 字符串和 []byte %s 输出字符串表示(string类型或[]byte) Printf(\"%s\",[]byte(\"Go语言\")) Go语言 %q 双引号围绕的字符串，由Go语法安全的转译 Printf(\"%q\",\"Go语言\") \"Go语言\" %x 十六进制，小写字母，每字节两个字符 Printf(\"%x\",\"golang\") 676f6c616e67 %X 十六进制，大写字母，每字节两个字符 Printf(\"%X\",\"golang\") 676F6C616E67 1.6 指针 %P 十六进制表示，前缀 0x Printf(\"%p\",&person) 0xc0420341c0 1.7 其他 + 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义） Printf(\"%+q\",\"中文\") \"\\u4e2d\\u6587\" - 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； # 切换格式：八进制数前加0（%#o） Printf(\"%#0\",46) 十六进制数前加0x（%#x）或0X（%#X） Printf(\"%#x\",46) 0x2e 指针去掉前面的0x（%#p）；） fmt.Printf(\"%#p\",&person) c0420441b0 对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串； Printf(\"%#q\",'中') '中' 对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值； Printf(\"%#U\",'中') U+4E2D '中' ' ' (空格)为数值中省略的正负号流出空白(% d); Printf(\"% d\",16) 16 以十六进制(% x,% X)打印字符串或切片时，在字节之间用空格隔开 Printf(\"% x\",\"abc\") 61 62 63 0 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面 2. 实例 package main import \"fmt\" func main() { type Person struct { Name string } var people = Person{Name: \"mark\"} //1.普通占位符 //%v(相应值的默认格式) fmt.Printf(\"%v\", people) //{mark} //%+v(打印结构体时，会添加字段名) fmt.Printf(\"%+v\", people) //{Name:mark} //%#v(相应值的Go语法表示) fmt.Printf(\"%#v\", people) //main.Person{Name:\"mark\"} //%T(相应值的类型的Go语法表示) fmt.Printf(\"%T\", people) //main.Person //%%(字面上的百分号，并非值的占位符) fmt.Printf(\"%%\") //% //2.布尔占位符 //%t(true 或 false) fmt.Printf(\"%t\", true) //true //3.整数占位符 //%b(二进制表示) fmt.Printf(\"%b\", 5) //101 //%c(相应Unicode码点所表示的字符) fmt.Printf(\"%c\", 0x4E2D) //中 //%d(十进制表示) fmt.Printf(\"%d\", 0x12) //18 //%o(八进制表示) fmt.Printf(\"%o\", 10) //12 //%q(单引号围绕的字符字面值，由Go语法安全地转义) fmt.Printf(\"%q\", 0x4E2D) //'中' //%x(十六进制表示，字母形式为小写a-f) fmt.Printf(\"%x\", 13) //d //%X(十六进制表示，字母形式为小写A-F) fmt.Printf(\"%X\", 13) //D //%U(Unicode格式：U+1234，等同于 \"U+%04X\") fmt.Printf(\"%U\", 0x4E2D) //U+4E2D //4.浮点数和复数的组成部分 //%b(无小数部分的，指数为二的幂的科学计数法) fmt.Printf(\"%b\", 10.2) //5742089524897382p-49 //%e(科学计数法,例如 -1234.456e+78) fmt.Printf(\"%e\", 10.2) //1.020000e+01 //%E(科学计数法,例如 -1234.456E+78) fmt.Printf(\"%E\", 10.2) //1.020000E+01 //%f(有小数点而无指数，例如123.456) fmt.Printf(\"%f\", 10.2) //10.200000 //%g(根据情况选择%e或%f以产生更紧凑的(无末尾的0)) fmt.Printf(\"%g\", 10.20) //10.2 //%G(根据情况选择%E或%f以产生更紧凑的(无末尾的0)) fmt.Printf(\"%G\", 10.20+2i) //(10.2+2i) //5.字符串与字节切片 //%s(输出字符串表示(string类型或[]byte)) fmt.Printf(\"%s\", []byte(\"Go语言\")) //Go语言 //%q(双引号围绕的字符串，由Go语法安全地转义) fmt.Printf(\"%q\", \"Go语言\") //\"Go语言\" //%x(十六进制，小写字母，每字节两个字符) fmt.Printf(\"%x\", \"golang\") //676f6c616e67 //%X(十六进制，大写字母，每字节两个字符) fmt.Printf(\"%X\", \"golang\") //676F6C616E67 //6.指针 //%p(十六进制表示，前缀0x) fmt.Printf(\"%p\", &people) //0xc0420421d0 } 参考 https://www.cnblogs.com/Survivalist/articles/10287297.html http://static.markbest.site/blog/88.html https://blog.csdn.net/chenbaoke/article/details/39932845 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 14:15:47 "},"Go-Package/go-os.html":{"url":"Go-Package/go-os.html","title":"go 包 os 文件操作","keywords":"","body":"Go 包 os 文件操作1 简介2 练习2.1 环境变量2.2 文件打开方式与打开模式（运用OpenFile函数）2.3 文件信息2.4 文件/目录操作2.5 文件/目录对象2.6 文件对象属性操纵2.7 文件对象读写操作Go 包 os 文件操作 1 简介 Go 在 os 中提供了文件的基本操作，包括通常意义的打开、创建、读写等操作，除此以外为了追求便捷以及性能上，Go 还在 io/ioutil 以及 bufio 提供一些其他函数供开发者使用 2 练习 2.1 环境变量 2.1.1 获取所有环境变量, 返回变量列表 func Environ() []string package main import ( \"fmt\" \"os\" \"strings\" ) func main() { envs := os.Environ() for _, env := range envs { cache := strings.Split(env, \"=\") fmt.Printf(` key: %s value: %s `, cache[0], cache[1]) } } [root@localhost os]# go run os1.go key: XDG_SESSION_ID value: 27 key: GUESTFISH_INIT value: \\e[1;34m key: HOSTNAME value: localhost.localdomain ...... 2.1.2 获取指定环境变量 func Getenv(key string) string package main import ( \"fmt\" \"os\" ) func main() { fmt.Println(os.Getenv(\"GOPATH\")) } [root@localhost os]# go run os2.go /usr/local/gopath 2.1.3 设置环境变量 func Setenv(key, value string) error package main import ( \"fmt\" \"os\" ) func main() { fmt.Println(os.Getenv(\"GOPATH\")) if err := os.Setenv(\"GOPATH\", \"./GO/bin\"); err != nil { fmt.Println(err) } else { fmt.Println(\"success\") } } [root@localhost os]# go run os3.go /usr/local/gopath success 2.1.4 清除所有环境变量 func os.Clearenv() func main() { data := os.Environ() fmt.Println(data) os.Clearenv() data = os.Environ() fmt.Println(data) } 2.2 文件打开方式与打开模式（运用OpenFile函数） //打开方式 const ( //只读模式 O_RDONLY int = syscall.O_RDONLY // open the file read-only. //只写模式 O_WRONLY int = syscall.O_WRONLY // open the file write-only. //可读可写 O_RDWR int = syscall.O_RDWR // open the file read-write. //追加内容 O_APPEND int = syscall.O_APPEND // append data to the file when writing. //创建文件,如果文件不存在 O_CREATE int = syscall.O_CREAT // create a new file if none exists. //与创建文件一同使用,文件必须存在 O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist //打开一个同步的文件流 O_SYNC int = syscall.O_SYNC // open for synchronous I/O. //如果可能,打开时缩短文件 O_TRUNC int = syscall.O_TRUNC // if possible, truncate file when opened. ) 打开模式 const ( // 单字符是被String方法用于格式化的属性缩写。 ModeDir FileMode = 1 2.3 文件信息 type FileInfo interface { Name() string // 文件的名字（不含扩展名） Size() int64 // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同 Mode() FileMode // 文件的模式位 ModTime() time.Time // 文件的修改时间 IsDir() bool // 等价于Mode().IsDir() Sys() interface{} // 底层数据来源（可以返回nil） } 2.3.1 获取文件信息对象, 符号链接将跳转 func Stat(name string) (fi FileInfo, err error) package main import ( \"fmt\" \"os\" ) func main() { fi, _ := os.Stat(\"./1.txt\") fmt.Println(fi.Size()) } [root@localhost os]# go run os4.go 6 2.3.2 获取文件信息对象, 符号链接不跳转 package main import ( \"fmt\" \"os\" ) func main() { fi, _ := os.Lstat(\"./1.txt\") fmt.Println(fi.Size()) } [root@localhost os]# go run os5.go 6 2.3.3 （重点）根据错误，判断 文件或目录是否存在 package main import ( \"fmt\" \"os\" ) func main() { if _, err := os.Open(\"./empty.js\"); err != nil { // false 不存在 true 存在 emptyErr := os.IsExist(err) fmt.Println(emptyErr, \"\\n\", err) } } [root@localhost os]# go run os6.go false open ./empty.js: no such file or directory 2.3.4 IsExist 反义方法 package main import ( \"fmt\" \"os\" ) func main() { if _, err := os.Open(\"./empty.js\"); err != nil { // false 不存在 true 存在 emptyErr := os.IsNotExist(err) fmt.Println(emptyErr, \"\\n\", err) } } [root@localhost os]# go run os7.go true open ./empty.js: no such file or directory 2.3.5 根据错误，判断是否为权限错误 package main import ( \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"./cache.js\") _, err := file.WriteString(\"// new info\") if err != nil { fmt.Println(os.IsPermission(err)) } defer file.Close() } [root@localhost os]# go run os8.go false 2.4 文件/目录操作 属性操作 2.4.1 （重点）获取当前工作目录 func Getwd() (dir string, err error) package main import ( \"fmt\" \"os\" ) func main() { path, _ := os.Getwd() fmt.Println(path) } [root@localhost os]# pwd /root/go/os [root@localhost os]# go run os9.go /root/go/os 2.4.2 修改当前，工作目录 func Chdir(dir string) error package main import ( \"fmt\" \"os\" ) func main() { path1, _ := os.Getwd() fmt.Println(path1) os.Chdir(\"./../\") path, _ := os.Getwd() fmt.Println(path) } [root@localhost os]# go run os10.go /root/go/os /root/go 2.4.3 修改文件的 FileMode func Chmod(name string, mode FileMode) error 2.4.4 修改文件的 访问时间和修改时间 func Chtimes(name string, atime time.Time, mtime time.Time) error package main import ( \"fmt\" \"os\" \"time\" ) func main() { fmt.Println(os.Getwd()) path := \"test.txt\" os.Chtimes(path, time.Now(), time.Now()) fi, _ := os.Stat(path) fmt.Println(fi.ModTime()) } [root@localhost os]# go run os11.go /root/go/os 2020-04-02 12:12:37.525936298 +0800 CST 下面是：增删改查 2.4.5 （重点）创建目录 func Mkdir(name string, perm FileMode) error package main import ( \"fmt\" \"os\" ) func main() { if err := os.Mkdir(\"test\", os.ModeDir); err != nil { fmt.Println(err) } else { fmt.Println(\"success\") } } [root@localhost os]# go run os12.go success [root@localhost os]# go run os12.go mkdir test: file exists 2.4.6 递归创建目录 func MkdirAll(path string, perm FileMode) error package main import ( \"fmt\" \"os\" ) func main() { if err := os.MkdirAll(\"test01/test\", os.ModeDir); err != nil { fmt.Println(err) } else { fmt.Println(\"success\") } } [root@localhost os]# go run os13.go success 2.4.7 移除文件或目录(单一文件) func Remove(name string) error package main import ( \"fmt\" \"os\" ) func main() { if err := os.Remove(\"test\"); err != nil { fmt.Println(err) } else { fmt.Println(\"success\") } } [root@localhost os]# go run os14.go success [root@localhost os]# ls test ls: 无法访问test: 没有那个文件或目录 [root@localhost os]# go run os14.go remove test: no such file or directory 2.4.8 递归删除文件或目录 func RemoveAll(path string) error package main import ( \"fmt\" \"os\" ) func main() { if err := os.RemoveAll(\"test01\"); err != nil { fmt.Println(err) } else { fmt.Println(\"success\") } } [root@localhost os]# go run os15.go success 2.4.8 文件重名或移动 func Rename(oldpath, newpath string) error package main import ( \"fmt\" \"os\" ) func main() { // 重命名 err := os.Rename(\"test.txt\", \"test01.js\") if err != nil { fmt.Println(err) } err = os.Mkdir(\"test\", os.ModeDir) if err != nil { fmt.Println(err) } // 移动 err = os.Rename(\"test01.js\", \"test/text01.txt\") if err != nil { fmt.Println(err) } } [root@localhost os]# go run os16.go [root@localhost os]# go run os16.go rename test.txt test01.js: no such file or directory mkdir test: file exists rename test01.js test/text01.txt: no such file or directory [root@localhost os]# ls test/ text01.txt 2.4.9 修改文件大小 func Truncate(name string, size int64) error package main import ( \"fmt\" \"os\" ) func main() { path := \"test/text01.txt\" fi, err := os.Stat(path) if err != nil { fmt.Println(err) os.Exit(1) } size := fi.Size() fmt.Println(size) // 截取长度 size = int64(float64(size) * 0.5) os.Truncate(path, size) fi, _ = os.Stat(path) fmt.Println(fi.Size()) } [root@localhost os]# cat test/text01.txt abc 123 [root@localhost os]# go run os17.go &{text01.txt 8 420 {99442120 63721429367 0x570b80} {64768 3725573 1 33188 0 0 0 0 8 4096 8 {1585832567 99442120} {1585832567 99442120} {1585832567 101442065} [0 0 0]}} 8 4 [root@localhost os]# cat test/text01.txt #123被删除 abc 2.4.10 比较两个文件信息对象，是否指向同一文件 func SameFile(fi1, fi2 FileInfo) bool package main import ( \"fmt\" \"os\" ) func main() { path := \"test/text01.txt\" fi_1, _ := os.Stat(path) fi_2, _ := os.Stat(path) fmt.Println(os.SameFile(fi_1, fi_2)) } [root@localhost os]# vim os18.go^C [root@localhost os]# go run os18.go true 2.5 文件/目录对象 2.5.1 （重点）创建文件, 如果文件存在，清空原文件 func Create(name string) (file *File, err error) package main import ( \"fmt\" \"os\" ) func main() { file, _ := os.Create(\"./new_file.js\") fmt.Println(file.Name()) } [root@localhost os]# go run os19.go ./new_file.js [root@localhost os]# ls new_file.js new_file.js 2.5.2 打开文件，获取文件对象, 以读取模式打开 Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。 所以，Open()只能用于读取文件。 func Open(name string) (file *File, err error) package main import ( \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"./new_file.js\") fmt.Println(file.Name()) } [root@localhost os]# go run os20.go ./new_file.js [root@localhost os]# rm -rf new_file.js [root@localhost os]# go run os20.go panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x48d6f0] goroutine 1 [running]: os.(*File).Name(...) /usr/local/go/src/os/file.go:54 main.main() /root/go/os/os20.go:11 +0x50 exit status 2 2.5.3 （重点）以指定模式，打开文件 func OpenFile(name string, flag int, perm FileMode) (file *File, err error) package main import ( \"fmt\" \"os\" ) func main() { file, _ := os.OpenFile(\"./new_file.js\", os.O_RDONLY, os.ModeAppend) fmt.Println(file.Name()) } [root@localhost os]# cat new_file.js [root@localhost os]# go run os21.go ./new_file.js 2.6 文件对象属性操纵 2.6.1 获取文件路径 Name func (f *File) Name() string 2.6.2 获取文件信息对象 Stat func (f *File) Stat() (fi FileInfo, err error) 2.6.3 将当前工作路径修改为文件对象目录， 文件对象必须为目录, 该接口不支持window Chdir func (f *File) Chdir() error 2.6.4 修改文件模式 Chmod func (f *File) Chmod(mode FileMode) error Truncate 2.6.5 修改文件对象size func (f *File) Truncate(size int64) error 2.7 文件对象读写操作 2.7.1 读取文件内容, 读入长度取决 容器切片长度 Read func (f *File) Read(b []byte) (n int, err error) package main import ( \"fmt\" \"os\" ) func main() { bt := make([]byte, 10) file, _ := os.Open(\"./new_file.js\") file.Read(bt) defer file.Close() fmt.Println(string(bt)) } [root@localhost os]# cat new_file.js 12345679890 nihao,my name is ghostwritten [root@localhost os]# go run os22.go 1234567989 2.7.2 从某位置，读取文件内容 ReadAt func (f *File) ReadAt(b []byte, off int64) (n int, err error) package main import ( \"fmt\" \"os\" ) func main() { bt := make([]byte, 100) file, _ := os.Open(\"test/text01.txt\") file.ReadAt(bt, 2) fmt.Println(string(bt)) } [root@localhost os]# cat test/text01.txt abcdefgh [root@localhost os]# go run os23.go cdefgh 2.7.3 （重点）写入内容 Write func (f *File) Write(b []byte) (n int, err error) package main import ( \"fmt\" \"os\" ) func main() { file, err := os.OpenFile(\"test/text01.txt\", os.O_RDWR, os.ModeAppend) if err != nil { fmt.Println(\"err: \", err) os.Exit(1) } defer file.Close() if n, err := file.Write([]byte(\"// new info\")); err != nil { fmt.Println(err) } else { fmt.Println(n) } } [root@localhost os]# go run os24.go 11 [root@localhost os]# cat test/text01.txt // new info 2.7.4 写入字符 WriteString func (f *File) WriteString(s string) (ret int, err error) package main import ( \"fmt\" \"os\" ) func main() { file, err := os.OpenFile(\"test/text01.txt\", os.O_RDWR, os.ModeAppend) if err != nil { fmt.Println(\"err: \", err) os.Exit(1) } defer file.Close() if n, err := file.Write([]byte(\"// new info\")); err != nil { fmt.Println(err) } else { fmt.Println(n) } } [root@localhost os]# go run os25.go 12 [root@localhost os]# cat test/text01.txt // test info 2.7.5 从指定位置，写入 WriteAt func (f *File) WriteAt(b []byte, off int64) (n int, err error) package main import ( \"fmt\" \"os\" ) func main() { file, err := os.OpenFile(\"test/text01.txt\", os.O_RDWR, os.ModeAppend) if err != nil { fmt.Println(\"err: \", err) os.Exit(1) } defer file.Close() if n, err := file.WriteAt([]byte(\" append \"), 5); err != nil { fmt.Println(err) } else { fmt.Println(n) } } [root@localhost os]# go run os26.go 8 [root@localhost os]# cat test/text01.txt // te append 2.7.6 设置下次读写位置 Seek func (f *File) Seek(offset int64, whence int) (ret int64, err error) package main import ( \"fmt\" \"os\" ) func main() { f, err := os.OpenFile(\"test/text01.txt\", os.O_RDWR, os.ModeAppend) if err != nil { fmt.Println(\"err: \", err) os.Exit(1) } defer f.Close() f.Seek(2, 0) buffer := make([]byte, 5) // Read 后文件指针也会偏移 n, err := f.Read(buffer) if err != nil { fmt.Println(nil) return } fmt.Printf(\"n is %d, buffer content is : %s\\n\", n, buffer) // 获取文件指针当前位置 cur_offset, _ := f.Seek(0, os.SEEK_CUR) fmt.Printf(\"current offset is %d\\n\", cur_offset) } [root@localhost os]# go run os27.go n is 5, buffer content is : 34567 current offset is 7 [root@localhost os]# cat test/text01.txt 1234567890abcdefg 参考： https://www.cnblogs.com/saryli/p/11691142.html https://www.cnblogs.com/wdliu/p/9239140.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 14:26:39 "}}